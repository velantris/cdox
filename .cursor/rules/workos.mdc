---
description: When implementing Work OS or auth 
alwaysApply: false
---
Directory structure:
└── workos-authkit-nextjs/
    ├── README.md
    ├── jest.config.ts
    ├── jest.setup.ts
    ├── LICENSE
    ├── package.json
    ├── tsconfig.json
    ├── .eslintignore
    ├── .eslintrc.cjs
    ├── .prettierrc
    ├── __tests__/
    │   ├── actions.spec.ts
    │   ├── auth.spec.ts
    │   ├── authkit-callback-route.spec.ts
    │   ├── authkit-provider.spec.tsx
    │   ├── button.spec.tsx
    │   ├── cookie.spec.ts
    │   ├── get-authorization-url.spec.ts
    │   ├── impersonation.spec.tsx
    │   ├── min-max-button.spec.tsx
    │   ├── session.spec.ts
    │   ├── test-helpers.ts
    │   ├── useAccessToken.spec.tsx
    │   ├── useTokenClaims.spec.tsx
    │   ├── utils.spec.ts
    │   └── workos.spec.ts
    ├── src/
    │   ├── actions.ts
    │   ├── auth.ts
    │   ├── authkit-callback-route.ts
    │   ├── cookie.ts
    │   ├── env-variables.ts
    │   ├── get-authorization-url.ts
    │   ├── index.ts
    │   ├── interfaces.ts
    │   ├── middleware.ts
    │   ├── session.ts
    │   ├── utils.ts
    │   ├── workos.ts
    │   └── components/
    │       ├── authkit-provider.tsx
    │       ├── button.tsx
    │       ├── impersonation.tsx
    │       ├── index.ts
    │       ├── min-max-button.tsx
    │       ├── useAccessToken.ts
    │       └── useTokenClaims.ts
    ├── types/
    │   └── react.d.ts
    └── .github/
        ├── CODEOWNERS
        ├── ISSUE_TEMPLATE/
        │   └── bug_report.md
        └── workflows/
            ├── ci.yml
            ├── coana-analysis.yml
            ├── coana-guardrail.yml
            └── release.yml


Files Content:

================================================
FILE: README.md
================================================
# AuthKit Next.js Library

The AuthKit library for Next.js provides convenient helpers for authentication and session management using WorkOS & AuthKit with Next.js.

> Note: This library is intended for use with the Next.js App Router.

## Installation

Install the package with:

```
npm i @workos-inc/authkit-nextjs
```

or

```
yarn add @workos-inc/authkit-nextjs
```

## Video tutorial

<a href="https://youtu.be/W8TmptLkEvA?feature=shared" target="_blank">
  <img src="https://github.com/user-attachments/assets/08c77835-1140-412a-baa9-a587ab27fc5e" alt="YouTube tutorial: Next.js App Router Authentication with AuthKit" style="display: block; width: 100%; max-width: 720px; height: auto; aspect-ratio: 16/9; object-fit: cover; object-position: center; margin: 1em auto;" onerror="this.onerror=null; this.src='https://i3.ytimg.com/vi/W8TmptLkEvA/maxresdefault.jpg'" />
</a>

## Pre-flight

Make sure the following values are present in your `.env.local` environment variables file. The client ID and API key can be found in the [WorkOS dashboard](https://dashboard.workos.com), and the redirect URI can also be configured there.

```sh
WORKOS_CLIENT_ID="client_..." # retrieved from the WorkOS dashboard
WORKOS_API_KEY="sk_test_..." # retrieved from the WorkOS dashboard
WORKOS_COOKIE_PASSWORD="<your password>" # generate a secure password here
NEXT_PUBLIC_WORKOS_REDIRECT_URI="http://localhost:3000/callback" # configured in the WorkOS dashboard
```

`WORKOS_COOKIE_PASSWORD` is the private key used to encrypt the session cookie. It has to be at least 32 characters long. You can use the [1Password generator](https://1password.com/password-generator/) or the `openssl` library to generate a strong password via the command line:

```
openssl rand -base64 24
```

To use the `signOut` method, you'll need to set a default Logout URI in your WorkOS dashboard settings under "Redirects".

### Optional configuration

Certain environment variables are optional and can be used to debug or configure cookie settings.

| Environment Variable | Default Value | Description |
|---------------------|---------------|-------------|
| `WORKOS_COOKIE_MAX_AGE` | `34560000` (400 days) | Maximum age of the cookie in seconds |
| `WORKOS_COOKIE_DOMAIN` | None | Domain for the cookie. When empty, the cookie is only valid for the current domain |
| `WORKOS_COOKIE_NAME` | `'wos-session'` | Name of the session cookie |
| `WORKOS_API_HOSTNAME` | `'api.workos.com'` | Base WorkOS API URL |
| `WORKOS_API_HTTPS` | `true` | Whether to use HTTPS in API calls |
| `WORKOS_API_PORT` | None | Port to use for API calls. When not set, uses standard ports (443 for HTTPS, 80 for HTTP) |
| `WORKOS_COOKIE_SAMESITE` | `'lax'` | SameSite attribute for cookies. Options: `'lax'`, `'strict'`, or `'none'` |

Example usage:
```sh
WORKOS_COOKIE_MAX_AGE='600'
WORKOS_COOKIE_DOMAIN='example.com'
WORKOS_COOKIE_NAME='my-auth-cookie'
```

> [!WARNING]
> Setting `WORKOS_COOKIE_SAMESITE='none'` allows cookies to be sent in cross-origin contexts (like iframes), but reduces protection against CSRF attacks. This setting forces cookies to be secure (HTTPS only) and should only be used when absolutely necessary for your application architecture.

> [!TIP] >`WORKOS_COOKIE_DOMAIN` can be used to share WorkOS sessions between apps/domains. Note: The `WORKOS_COOKIE_PASSWORD` would need to be the same across apps/domains. Not needed for most use cases.

## Setup

### Callback route

WorkOS requires that you have a callback URL to redirect users back to after they've authenticated. In your Next.js app, [expose an API route](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and add the following.

```ts
import { handleAuth } from '@workos-inc/authkit-nextjs';

export const GET = handleAuth();
```

Make sure this route matches the `WORKOS_REDIRECT_URI` variable and the configured redirect URI in your WorkOS dashboard. For instance if your redirect URI is `http://localhost:3000/auth/callback` then you'd put the above code in `/app/auth/callback/route.ts`.

You can also control the pathname the user will be sent to after signing-in by passing a `returnPathname` option to `handleAuth` like so:

```ts
export const GET = handleAuth({ returnPathname: '/dashboard' });
```

If your application needs to persist data upon a successful authentication, like the `oauthTokens` from an upstream provider, you can pass in a `onSuccess` function that will get called after the user has successfully authenticated:

```ts
export const GET = handleAuth({
  onSuccess: async ({ user, oauthTokens, authenticationMethod, organizationId }) => {
    await saveTokens(oauthTokens);
    if (authenticationMethod) {
      await saveAuthMethod(user.id, authenticationMethod);
    }
  },
});
```

`handleAuth` can be used with the following options.

| Option           | Default     | Description                                                                                                                                                                                           |
| ---------------- | ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `returnPathname` | `/`         | The pathname to redirect the user to after signing in                                                                                                                                                 |
| `baseURL`        | `undefined` | The base URL to use for the redirect URI instead of the one in the request. Useful if the app is being run in a container like docker where the hostname can be different from the one in the request |
| `onSuccess`      | `undefined` | A function that receives successful authentication data and can be used for side-effects like persisting tokens                                                                                       |
| `onError`        | `undefined` | A function that can receive the error and the request and handle the error in its own way.                                                                                                            |

#### onSuccess callback data

The `onSuccess` callback receives the following data:

| Property               | Type                        | Description                                                                                        |
| ---------------------- | --------------------------- | -------------------------------------------------------------------------------------------------- |
| `user`                 | `User`                      | The authenticated user object                                                                      |
| `accessToken`          | `string`                    | JWT access token                                                                                   |
| `refreshToken`         | `string`                    | Refresh token for session renewal                                                                  |
| `impersonator`         | `Impersonator \| undefined` | Present if user is being impersonated                                                              |
| `oauthTokens`          | `OauthTokens \| undefined`  | OAuth tokens from upstream provider                                                                |
| `authenticationMethod` | `string \| undefined`       | How the user authenticated (e.g., 'password', 'google-oauth'). Only available during initial login |
| `organizationId`       | `string \| undefined`       | Organization context of authentication                                                             |

**Note**: `authenticationMethod` is only provided during the initial authentication callback. It will not be available in subsequent requests or session refreshes.

### Middleware

This library relies on [Next.js middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware) to provide session management for routes. Put the following in your `middleware.ts` file in the root of your project:

```ts
import { authkitMiddleware } from '@workos-inc/authkit-nextjs';

export default authkitMiddleware();

// Match against pages that require auth
// Leave this out if you want auth on every resource (including images, css etc.)
export const config = { matcher: ['/', '/admin'] };
```

The middleware can be configured with several options.

| Option           | Default     | Description                                                                                            |
| ---------------- | ----------- | ------------------------------------------------------------------------------------------------------ |
| `redirectUri`    | `undefined` | Used in cases where you need your redirect URI to be set dynamically (e.g. Vercel preview deployments) |
| `middlewareAuth` | `undefined` | Used to configure middleware auth options. See [middleware auth](#middleware-auth) for more details.   |
| `debug`          | `false`     | Enables debug logs.                                                                                    |
| `signUpPaths`    | `[]`        | Used to specify paths that should use the 'sign-up' screen hint when redirecting to AuthKit.           |

#### Custom redirect URI

In cases where you need your redirect URI to be set dynamically (e.g. Vercel preview deployments), use the `redirectUri` option in `authkitMiddleware`:

```ts
import { authkitMiddleware } from '@workos-inc/authkit-nextjs';

export default authkitMiddleware({
  redirectUri: 'https://foo.example.com/callback',
});

// Match against pages that require auth
// Leave this out if you want auth on every resource (including images, css etc.)
export const config = { matcher: ['/', '/admin'] };
```

Custom redirect URIs will be used over a redirect URI configured in the environment variables.

## Usage

### Wrap your app in `AuthKitProvider`

Use `AuthKitProvider` to wrap your app layout, which provides client side auth methods adds protections for auth edge cases.

```jsx
import { AuthKitProvider } from '@workos-inc/authkit-nextjs/components';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <AuthKitProvider>{children}</AuthKitProvider>
      </body>
    </html>
  );
}
```

### Get the current user in a server component

For pages where you want to display a signed-in and signed-out view, use `withAuth` to retrieve the user session from WorkOS.

```jsx
import Link from 'next/link';
import { getSignInUrl, getSignUpUrl, withAuth, signOut } from '@workos-inc/authkit-nextjs';

export default async function HomePage() {
  // Retrieves the user from the session or returns `null` if no user is signed in
  const { user } = await withAuth();

  if (!user) {
    // Get the URL to redirect the user to AuthKit to sign in
    const signInUrl = await getSignInUrl();

    // Get the URL to redirect the user to AuthKit to sign up
    const signUpUrl = await getSignUpUrl();

    return (
      <>
        <Link href={signInUrl}>Log in</Link>
        <Link href={signUpUrl}>Sign Up</Link>
      </>
    );
  }

  return (
    <form
      action={async () => {
        'use server';
        await signOut();
      }}
    >
      <p>Welcome back {user?.firstName && `, ${user?.firstName}`}</p>
      <button type="submit">Sign out</button>
    </form>
  );
}
```

### Get the current user in a client component

For client components, use the `useAuth` hook to get the current user session.

```jsx
// Note the updated import path
import { useAuth } from '@workos-inc/authkit-nextjs/components';

export default function MyComponent() {
  // Retrieves the user from the session or returns `null` if no user is signed in
  const { user, loading } = useAuth();

  if (loading) {
    return <div>Loading...</div>;
  }

  return <div>{user?.firstName}</div>;
}
```

### Requiring auth

For pages where a signed-in user is mandatory, you can use the `ensureSignedIn` option:

```jsx
// Server component
const { user } = await withAuth({ ensureSignedIn: true });

// Client component
const { user, loading } = useAuth({ ensureSignedIn: true });
```

Enabling `ensureSignedIn` will redirect users to AuthKit if they attempt to access the page without being authenticated.

### Refreshing the session

Use the `refreshSession` method in a server action or route handler to fetch the latest session details, including any changes to the user's roles or permissions.

The `organizationId` parameter can be passed to `refreshSession` in order to switch the session to a different organization. If the current session is not authorized for the next organization, an appropriate [authentication error](https://workos.com/docs/reference/user-management/authentication-errors) will be returned.

In client components, you can refresh the session with the `refreshAuth` hook.

```tsx
'use client';

import { useAuth } from '@workos-inc/authkit-nextjs/components';
import React, { useEffect } from 'react';

export function SwitchOrganizationButton() {
  const { user, organizationId, loading, refreshAuth } = useAuth();

  useEffect(() => {
    // This will log out the new organizationId after refreshing the session
    console.log('organizationId', organizationId);
  }, [organizationId]);

  if (loading) {
    return <div>Loading...</div>;
  }

  const handleRefreshSession = async () => {
    const result = await refreshAuth({
      // Provide the organizationId to switch to
      organizationId: 'org_123',
    });
    if (result?.error) {
      console.log('Error refreshing session:', result.error);
    }
  };

  if (user) {
    return <button onClick={handleRefreshSession}>Refresh session</button>;
  } else {
    return <div>Not signed in</div>;
  }
}
```

### Access Token Management

#### useAccessToken Hook

This library provides a `useAccessToken` hook for client-side access token management with automatic refresh functionality.

##### Features

- Automatic token refresh before expiration
- Manual refresh capability
- Loading and error states
- Synchronized with the main authentication session
- Race condition prevention

##### When to Use

Use this hook when you need direct access to the JWT token for:

- Making authenticated API calls
- Setting up external auth-dependent libraries
- Implementing custom authentication logic

##### Basic Usage

```jsx
function ApiClient() {
  const { accessToken, loading, error, refresh } = useAccessToken();

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!accessToken) return <div>Not authenticated</div>;

  return (
    <div>
      <p>Token available: {accessToken.substring(0, 10)}...</p>
      <button onClick={refresh}>Refresh token</button>
    </div>
  );
}
```

##### API Reference

| Property      | Type                                 | Description                                   |
| ------------- | ------------------------------------ | --------------------------------------------- |
| `accessToken` | `string \| undefined`                | The current access token                      |
| `loading`     | `boolean`                            | True when token is being fetched or refreshed |
| `error`       | `Error \| null`                      | Error during token fetch/refresh, or null     |
| `refresh`     | `() => Promise<string \| undefined>` | Manually refresh the token                    |

##### Integration with useAuth

The `useAccessToken` hook automatically synchronizes with the main authentication session. When you call `refreshAuth()` from `useAuth`, the access token will update accordingly. Similarly, using the `refresh()` method from `useAccessToken` will update the entire authentication session.

##### Security Considerations

JWT tokens are sensitive credentials and should be handled carefully:

- Only use the token where necessary
- Don't store tokens in localStorage or sessionStorage
- Be cautious about exposing tokens in your application state

### Session Refresh Callbacks

When using the `authkit` function directly, you can provide callbacks to be notified when a session is refreshed:

```typescript
const { session, headers } = await authkit(request, {
  onSessionRefreshSuccess: async ({ accessToken, user, impersonator }) => {
    // Log successful refresh
    console.log(`Session refreshed for ${user.email}.`);
  },
  onSessionRefreshError: async ({ error, request }) => {
    // Log refresh failure
    console.error('Session refresh failed:', error);
    // Notify monitoring system
    await notifyMonitoring('session_refresh_failed', {
      url: request.url,
      error: error.message,
    });
  },
});
```

These callbacks provide a way to perform side effects when sessions are refreshed in the middleware. Common use cases include:

- Logging authentication events
- Updating last activity timestamps
- Triggering organization-specific data prefetching
- Recording failed refresh attempts

### Middleware auth

The default behavior of this library is to request authentication via the `withAuth` method on a per-page basis. There are some use cases where you don't want to call `withAuth` (e.g. you don't need user data for your page) or if you'd prefer a "secure by default" approach where every route defined in your middleware matcher is protected unless specified otherwise. In those cases you can opt-in to use middleware auth instead:

```ts
import { authkitMiddleware } from '@workos-inc/authkit-nextjs';

export default authkitMiddleware({
  middlewareAuth: {
    enabled: true,
    unauthenticatedPaths: ['/', '/about'],
  },
});

// Match against pages that require auth
// Leave this out if you want auth on every resource (including images, css etc.)
export const config = { matcher: ['/', '/admin/:path*', '/about'] };
```

In the above example the `/admin` page will require a user to be signed in, whereas `/` and `/about` can be accessed without signing in.

`unauthenticatedPaths` uses the same glob logic as the [Next.js matcher](https://nextjs.org/docs/pages/building-your-application/routing/middleware#matcher).

### Composing middleware

If you don't want to use `authkitMiddleware` and instead want to compose your own middleware, you can use the `authkit` method. In this mode you are responsible to handling what to do when there's no session on a protected route.

```ts
export default async function middleware(request: NextRequest) {
  // Perform logic before or after AuthKit

  // Auth object contains the session, response headers and an auhorization URL in the case that the session isn't valid
  // This method will automatically handle setting the cookie and refreshing the session
  const { session, headers, authorizationUrl } = await authkit(request, {
    debug: true,
  });

  // Control of what to do when there's no session on a protected route is left to the developer
  if (request.url.includes('/account') && !session.user) {
    console.log('No session on protected path');
    return NextResponse.redirect(authorizationUrl);

    // Alternatively you could redirect to your own login page, for example if you want to use your own UI instead of hosted AuthKit
    return NextResponse.redirect('/login');
  }

  // Headers from the authkit response need to be included in every non-redirect response to ensure that `withAuth` works as expected
  return NextResponse.next({
    headers: headers,
  });
}

// Match against the pages
export const config = { matcher: ['/', '/account/:path*'] };
```

### Signing out

Use the `signOut` method to sign out the current logged in user and redirect to your app's default Logout URI. The Logout URI is set in your WorkOS dashboard settings under "Redirect".

To use a non-default Logout URI, you can use the `returnTo` parameter.

```tsx
await signOut({ returnTo: 'https://your-app.com/signed-out' });
```

### Visualizing an impersonation

Render the `Impersonation` component in your app so that it is clear when someone is [impersonating a user](https://workos.com/docs/user-management/impersonation).
The component will display a frame with some information about the impersonated user, as well as a button to stop impersonating.

```jsx
import { Impersonation, AuthKitProvider } from '@workos-inc/authkit-nextjs/components';

export default function App() {
  return (
    <div>
      <AuthKitProvider>
        <Impersonation />
        {/* Your app content */}
      </AuthKitProvider>
    </div>
  );
}
```

### Get the access token

Sometimes it is useful to obtain the access token directly, for instance to make API requests to another service.

```jsx
import { withAuth } from '@workos-inc/authkit-nextjs';

export default async function HomePage() {
  const { accessToken } = await withAuth();

  if (!accessToken) {
    return <div>Not signed in</div>;
  }

  const serviceData = await fetch('/api/path', {
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });

  return <div>{serviceData}</div>;
}
```

### Sign up paths

The `signUpPaths` option can be passed to `authkitMiddleware` to specify paths that should use the 'sign-up' screen hint when redirecting to AuthKit. This is useful for cases where you want a path that mandates authentication to be treated as a sign up page.

```ts
import { authkitMiddleware } from '@workos-inc/authkit-nextjs';

export default authkitMiddleware({
  signUpPaths: ['/account/sign-up', '/dashboard/:path*'],
});
```

### Advanced: Direct access to the WorkOS client

For advanced use cases or functionality not covered by the helper methods, you can access the underlying WorkOS client directly:

```typescript
import { getWorkOS } from '@workos-inc/authkit-nextjs';

// Get the configured WorkOS client instance
const workos = getWorkOS();

// Use any WorkOS SDK method
const organizations = await workos.organizations.listOrganizations({
  limit: 10,
});
```

### Advanced: Custom authentication flows

While the standard authentication flow handles session management automatically, some use cases require manually creating and storing a session. This is useful for custom authentication flows like email verification or token exchange.

For these scenarios, you can use the `saveSession` function:

```typescript
import { saveSession } from '@workos-inc/authkit-nextjs';
import { getWorkOS } from '@workos-inc/authkit-nextjs';

// Example: Email verification flow
async function handleEmailVerification(req) {
  const { code } = await req.json();

  // Authenticate with the WorkOS API directly
  const authResponse = await getWorkOS().userManagement.authenticateWithEmailVerification({
    clientId: process.env.WORKOS_CLIENT_ID,
    code,
  });

  // Save the session data to a cookie
  await saveSession(
    {
      accessToken: authResponse.accessToken,
      refreshToken: authResponse.refreshToken,
      user: authResponse.user,
      impersonator: authResponse.impersonator,
    },
    req,
  );

  return Response.redirect('/dashboard');
}
```

> [!NOTE]
> This is an advanced API intended for specific integration scenarios, such as those users using self-hosted AuthKit. If you're using hosted AuthKit you should not need this.

The `saveSession` function accepts either a `NextRequest` object or a URL string as its second parameter.

```typescript
// With NextRequest
await saveSession(session, req);

// With URL string
await saveSession(session, 'https://example.com/callback');
```

### Debugging

To enable debug logs, initialize the middleware with the debug flag enabled.

```js
import { authkitMiddleware } from '@workos-inc/authkit-nextjs';

export default authkitMiddleware({ debug: true });
```

### Troubleshooting

#### NEXT_REDIRECT error when using try/catch blocks

Wrapping a `withAuth({ ensureSignedIn: true })` call in a try/catch block will cause a `NEXT_REDIRECT` error. This is because `withAuth` will attempt to redirect the user to AuthKit if no session is detected and redirects in Next must be [called outside a try/catch](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#redirecting).

#### Module build failed: UnhandledSchemeError: Reading from "node:crypto" is not handled by plugins (Unhandled scheme).

You may encounter this error if you attempt to import server side code from authkit-nextjs into a client component. Likely you are using `withAuth` in a client component instead of the `useAuth` hook. Either move the code to a server component or use the `useAuth` hook.



================================================
FILE: jest.config.ts
================================================
import type { Config } from 'jest';

const config: Config = {
  // Automatically clear mock calls, instances, contexts and results before every test
  clearMocks: true,

  // Indicates whether the coverage information should be collected while executing the test
  collectCoverage: true,

  // The directory where Jest should output its coverage files
  coverageDirectory: 'coverage',

  // Indicates which provider should be used to instrument code for coverage
  coverageProvider: 'babel',

  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1', // Handle ESM imports
  },

  // A preset that is used as a base for Jest's configuration
  preset: 'ts-jest',

  // Run tests from one or more projects
  projects: [
    {
      displayName: 'jsdom',
      testEnvironment: 'jsdom',
      testMatch: ['**/__tests__/**/*.spec.tsx'],
      transform: {
        '^.+\\.tsx?$': 'ts-jest', // Use ts-jest for TypeScript files
      },
      moduleNameMapper: {
        '^(\\.{1,2}/.*)\\.js$': '$1',
      },
    },
    {
      displayName: 'node',
      testEnvironment: 'node',
      testMatch: ['**/__tests__/**/*.spec.ts'],
      transform: {
        '^.+\\.tsx?$': 'ts-jest',
      },
      moduleNameMapper: {
        '^(\\.{1,2}/.*)\\.js$': '$1',
      },
      setupFiles: ['<rootDir>/jest.setup.ts'],
    },
  ],

  // Indicates whether each individual test should be reported during the run
  verbose: true,

  // Optionally, add these for better TypeScript support
  extensionsToTreatAsEsm: ['.ts'],

  coverageThreshold: {
    global: {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100,
    },
  },
};

export default config;



================================================
FILE: jest.setup.ts
================================================
process.env.WORKOS_API_KEY = 'sk_test_1234567890';
process.env.WORKOS_CLIENT_ID = 'client_1234567890';
process.env.WORKOS_COOKIE_PASSWORD = 'kR620keEzOIzPThfnMEAba8XYgKdQ5vg';
process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI = 'http://localhost:3000/callback';
process.env.WORKOS_COOKIE_DOMAIN = 'example.com';

// Mock the next/headers module
jest.mock('next/headers', () => {
  const cookieStore = new Map();
  const headersStore = new Map();

  return {
    headers: async () => ({
      delete: jest.fn((name: string) => headersStore.delete(name)),
      get: jest.fn((name: string) => headersStore.get(name)),
      set: jest.fn((name: string, value: string) => headersStore.set(name, value)),
      _reset: () => {
        headersStore.clear();
      },
    }),
    cookies: async () => ({
      delete: jest.fn((nameOrObject: string | { name: string; [key: string]: unknown }) => {
        const cookieName = typeof nameOrObject === 'string' ? nameOrObject : nameOrObject.name;
        cookieStore.delete(cookieName);
      }),
      get: jest.fn((name: string) => cookieStore.get(name)),
      getAll: jest.fn(() => Array.from(cookieStore.entries())),
      set: jest.fn((name: string, value: string | { [key: string]: string | number | boolean }) =>
        cookieStore.set(name, {
          name,
          value,
        }),
      ),
      _reset: () => {
        cookieStore.clear();
      },
    }),
  };
});

jest.mock('next/navigation', () => ({
  redirect: jest.fn(),
}));



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2024 WorkOS

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: package.json
================================================
{
  "name": "@workos-inc/authkit-nextjs",
  "version": "2.4.2",
  "description": "Authentication and session helpers for using WorkOS & AuthKit with Next.js",
  "sideEffects": false,
  "type": "module",
  "main": "./dist/esm/index.js",
  "types": "./dist/esm/types/index.d.ts",
  "files": [
    "dist",
    "src",
    "LICENSE",
    "README.md"
  ],
  "exports": {
    "./components": {
      "types": "./dist/esm/types/components/index.d.ts",
      "import": "./dist/esm/components/index.js"
    },
    ".": {
      "types": "./dist/esm/types/index.d.ts",
      "import": "./dist/esm/index.js"
    }
  },
  "scripts": {
    "clean": "rm -rf dist",
    "prebuild": "npm run clean",
    "build": "tsc --project tsconfig.json",
    "prepublishOnly": "npm run lint",
    "lint": "eslint \"src/**/*.ts*\"",
    "test": "jest",
    "test:watch": "jest --watch",
    "prettier": "prettier \"{src,__tests__}/**/*.{js,ts,tsx}\" --check",
    "format": "prettier \"{src,__tests__}/**/*.{js,ts,tsx}\" --write"
  },
  "dependencies": {
    "@workos-inc/node": "^7.37.1",
    "iron-session": "^8.0.1",
    "jose": "^5.2.3",
    "path-to-regexp": "^6.2.2"
  },
  "peerDependencies": {
    "next": "^13.5.9 || ^14.2.26 || ^15.2.3",
    "react": "^18.0 || ^19.0.0",
    "react-dom": "^18.0 || ^19.0.0"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.0.1",
    "@types/jest": "^29.5.14",
    "@types/node": "^20.11.28",
    "@types/react": "18.2.67",
    "@types/react-dom": "18.2.22",
    "eslint": "^8.29.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-require-extensions": "^0.1.3",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "next": "^15.0.1",
    "prettier": "^3.3.3",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "5.4.2",
    "typescript-eslint": "^7.2.0"
  },
  "license": "MIT",
  "homepage": "https://github.com/workos/authkit-nextjs#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/workos/authkit-nextjs.git"
  },
  "bugs": {
    "url": "https://github.com/workos/authkit-nextjs/issues"
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2018",
    "lib": ["DOM", "ESNext", "DOM.Iterable"],
    "jsx": "react",
    "sourceMap": true,
    "declaration": true,
    "importHelpers": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "alwaysStrict": true,
    "skipLibCheck": true,
    "outDir": "./dist/esm",
    "declarationDir": "./dist/esm/types",
    "module": "ES2020",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true
  },
  "exclude": ["**/*.spec.ts", "**/*.spec.tsx", "jest.config.ts", "jest.setup.ts", "/dist/**/*", "__tests__/**/*"]
}




================================================
FILE: .eslintignore
================================================
.eslintrc.cjs



================================================
FILE: .eslintrc.cjs
================================================
module.exports = {
  root: true,
  extends: [
		'eslint:recommended',
		'prettier',
    'plugin:@typescript-eslint/recommended',
    'plugin:require-extensions/recommended',
  ],
  plugins: ['require-extensions'],
};



================================================
FILE: .prettierrc
================================================
{
  "quoteProps": "consistent",
  "singleQuote": true,
  "trailingComma": "all",
  "printWidth": 120
}



================================================
FILE: __tests__/actions.spec.ts
================================================
import {
  checkSessionAction,
  handleSignOutAction,
  getOrganizationAction,
  getAuthAction,
  refreshAuthAction,
  switchToOrganizationAction,
  getAccessTokenAction,
  refreshAccessTokenAction,
} from '../src/actions.js';
import { signOut, switchToOrganization } from '../src/auth.js';
import { getWorkOS } from '../src/workos.js';
import { withAuth, refreshSession } from '../src/session.js';

jest.mock('../src/auth.js', () => ({
  signOut: jest.fn().mockResolvedValue(true),
  switchToOrganization: jest.fn().mockResolvedValue({ organizationId: 'org_123' }),
}));

const fakeWorkosInstance = {
  organizations: {
    getOrganization: jest.fn().mockResolvedValue({ id: 'org_123', name: 'Test Org' }),
  },
};
jest.mock('../src/workos.js', () => ({
  getWorkOS: jest.fn(() => fakeWorkosInstance),
}));

jest.mock('../src/session.js', () => ({
  withAuth: jest.fn().mockResolvedValue({ user: 'testUser', accessToken: 'access_token' }),
  refreshSession: jest.fn().mockResolvedValue({ session: 'newSession', accessToken: 'refreshed_token' }),
}));

describe('actions', () => {
  const workos = getWorkOS();
  describe('checkSessionAction', () => {
    it('should return true for authenticated users', async () => {
      const result = await checkSessionAction();
      expect(result).toBe(true);
    });
  });

  describe('handleSignOutAction', () => {
    it('should call signOut', async () => {
      await handleSignOutAction();
      expect(signOut).toHaveBeenCalled();
    });
  });

  describe('getOrganizationAction', () => {
    it('should return organization details', async () => {
      const organizationId = 'org_123';
      const result = await getOrganizationAction(organizationId);
      expect(workos.organizations.getOrganization).toHaveBeenCalledWith(organizationId);
      expect(result).toEqual({ id: 'org_123', name: 'Test Org' });
    });
  });

  describe('getAuthAction', () => {
    it('should return auth details', async () => {
      const result = await getAuthAction();
      expect(withAuth).toHaveBeenCalled();
      expect(result).toEqual({ user: 'testUser' });
    });
  });

  describe('refreshAuthAction', () => {
    it('should refresh session', async () => {
      const params = { ensureSignedIn: true, organizationId: 'org_123' };
      const result = await refreshAuthAction(params);
      expect(refreshSession).toHaveBeenCalledWith(params);
      expect(result).toEqual({ session: 'newSession' });
    });
  });

  describe('switchToOrganizationAction', () => {
    it('should switch organizations', async () => {
      const options = { returnTo: '/test' };
      const result = await switchToOrganizationAction('org_123', options);
      expect(switchToOrganization).toHaveBeenCalledWith('org_123', options);
      expect(result).toEqual({ organizationId: 'org_123' });
    });
  });

  describe('getAccessTokenAction', () => {
    it('should return access token', async () => {
      const result = await getAccessTokenAction();
      expect(withAuth).toHaveBeenCalled();
      expect(result).toEqual('access_token');
    });
  });

  describe('refreshAccessTokenAction', () => {
    it('should refresh access token', async () => {
      const result = await refreshAccessTokenAction();
      expect(refreshSession).toHaveBeenCalled();
      expect(result).toEqual('refreshed_token');
    });
  });
});



================================================
FILE: __tests__/auth.spec.ts
================================================
import { describe, it, expect, beforeEach, jest } from '@jest/globals';

import { getSignInUrl, getSignUpUrl, signOut, switchToOrganization } from '../src/auth.js';
import * as session from '../src/session.js';
import * as cache from 'next/cache';
import * as workosModule from '../src/workos.js';

// These are mocked in jest.setup.ts
import { cookies, headers } from 'next/headers';
import { redirect } from 'next/navigation';
import { generateSession, generateTestToken } from './test-helpers.js';
import { sealData } from 'iron-session';
import { getWorkOS } from '../src/workos.js';

const workos = getWorkOS();

jest.mock('next/cache', () => {
  const actual = jest.requireActual<typeof cache>('next/cache');
  return {
    ...actual,
    revalidateTag: jest.fn(),
    revalidatePath: jest.fn(),
  };
});

// Create a fake WorkOS instance that will be used only in the "on error" tests
const fakeWorkosInstance = {
  userManagement: {
    authenticateWithRefreshToken: jest.fn(),
    getAuthorizationUrl: jest.fn(),
    getJwksUrl: jest.fn(() => 'https://api.workos.com/sso/jwks/client_1234567890'),
    getLogoutUrl: jest.fn(),
  },
};

const revalidatePath = jest.mocked(cache.revalidatePath);
const revalidateTag = jest.mocked(cache.revalidateTag);
// We'll only use these in the "on error" tests
const authenticateWithRefreshToken = fakeWorkosInstance.userManagement.authenticateWithRefreshToken;
const getAuthorizationUrl = fakeWorkosInstance.userManagement.getAuthorizationUrl;

jest.mock('../src/session', () => {
  const actual = jest.requireActual<typeof session>('../src/session');

  return {
    ...actual,
    refreshSession: jest.fn(actual.refreshSession),
  };
});

describe('auth.ts', () => {
  beforeEach(async () => {
    // Clear all mocks between tests
    jest.clearAllMocks();

    // Reset the cookie store
    const nextCookies = await cookies();
    // @ts-expect-error - _reset is part of the mock
    nextCookies._reset();

    const nextHeaders = await headers();
    // @ts-expect-error - _reset is part of the mock
    nextHeaders._reset();
  });

  describe('getSignInUrl', () => {
    it('should return a valid URL', async () => {
      const url = await getSignInUrl();
      expect(url).toBeDefined();
      expect(() => new URL(url)).not.toThrow();
    });

    it('should use the organizationId if provided', async () => {
      const url = await getSignInUrl({ organizationId: 'org_123' });
      expect(url).toContain('organization_id=org_123');
      expect(url).toBeDefined();
      expect(() => new URL(url)).not.toThrow();
    });
  });

  describe('getSignUpUrl', () => {
    it('should return a valid URL', async () => {
      const url = await getSignUpUrl();
      expect(url).toBeDefined();
      expect(() => new URL(url)).not.toThrow();
    });
  });

  describe('switchToOrganization', () => {
    it('should refresh the session with the new organizationId', async () => {
      const nextHeaders = await headers();
      nextHeaders.set('x-url', 'http://localhost/test');
      await switchToOrganization('org_123');
      expect(revalidatePath).toHaveBeenCalledWith('http://localhost/test');
    });

    it('should revalidate the path and refresh the session with the new organizationId', async () => {
      const nextHeaders = await headers();
      nextHeaders.set('x-url', 'http://localhost/test');
      await switchToOrganization('org_123', { returnTo: '/test' });
      expect(session.refreshSession).toHaveBeenCalledTimes(1);
      expect(session.refreshSession).toHaveBeenCalledWith({ organizationId: 'org_123', ensureSignedIn: true });
      expect(revalidatePath).toHaveBeenCalledWith('/test');
    });

    it('should revalidate the provided tags and refresh the session with the new organizationId', async () => {
      const nextHeaders = await headers();
      nextHeaders.set('x-url', 'http://localhost/test');
      await switchToOrganization('org_123', { revalidationStrategy: 'tag', revalidationTags: ['tag1', 'tag2'] });
      expect(revalidateTag).toHaveBeenCalledTimes(2);
    });

    describe('on error', () => {
      beforeEach(async () => {
        const nextHeaders = await headers();
        nextHeaders.set('x-url', 'http://localhost/test');
        await generateSession();

        // Create a WorkOS-like object that matches what our tests need
        const mockWorkOS = {
          userManagement: fakeWorkosInstance.userManagement,
          // Add minimal properties to satisfy TypeScript
          createHttpClient: jest.fn(),
          createWebhookClient: jest.fn(),
          createActionsClient: jest.fn(),
          createIronSessionProvider: jest.fn(),
          apiKey: 'test',
          clientId: 'test',
          host: 'test',
          port: 443,
          protocol: 'https',
          headers: {},
          version: '0.0.0',
        };

        // Apply the mock for these tests only
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        jest.spyOn(workosModule, 'getWorkOS').mockImplementation(() => mockWorkOS as any);
      });

      afterEach(() => {
        // Restore all mocks after each test
        jest.restoreAllMocks();
      });

      it('should redirect to sign in when error is "sso_required"', async () => {
        authenticateWithRefreshToken.mockImplementation(() => {
          return Promise.reject({
            status: 500,
            requestID: 'sso_required',
            error: 'sso_required',
            errorDescription: 'User must authenticate using one of the matching connections.',
          });
        });

        await switchToOrganization('org_123');
        expect(getAuthorizationUrl).toHaveBeenCalledWith(expect.objectContaining({ organizationId: 'org_123' }));
        expect(redirect).toHaveBeenCalledTimes(1);
      });

      it('should redirect to sign in when error is "mfa_enrollment"', async () => {
        authenticateWithRefreshToken.mockImplementation(() => {
          return Promise.reject({
            status: 500,
            requestID: 'mfa_enrollment',
            error: 'mfa_enrollment',
            errorDescription: 'User must authenticate using one of the matching connections.',
          });
        });

        await switchToOrganization('org_123');
        expect(getAuthorizationUrl).toHaveBeenCalledWith(expect.objectContaining({ organizationId: 'org_123' }));
        expect(redirect).toHaveBeenCalledTimes(1);
      });

      it('should redirect to the authkit_redirect_url when provided', async () => {
        authenticateWithRefreshToken.mockImplementation(() => {
          return Promise.reject({
            rawData: {
              authkit_redirect_url: 'http://localhost/test',
            },
          });
        });
        await switchToOrganization('org_123');
        expect(redirect).toHaveBeenCalledWith('http://localhost/test');
      });

      it('throws other errors', async () => {
        authenticateWithRefreshToken.mockImplementation(() => {
          return Promise.reject(new Error('Fail'));
        });
        await expect(switchToOrganization('org_123')).rejects.toThrow('Fail');
      });
    });
  });

  describe('signOut', () => {
    it('should delete the cookie and redirect', async () => {
      const nextCookies = await cookies();
      const nextHeaders = await headers();

      nextHeaders.set('x-workos-middleware', 'true');
      nextCookies.set('wos-session', 'foo');

      await signOut();

      const sessionCookie = nextCookies.get('wos-session');

      expect(sessionCookie).toBeUndefined();
      expect(redirect).toHaveBeenCalledTimes(1);
      expect(redirect).toHaveBeenCalledWith('/');
    });

    it('should delete the cookie with a specific domain', async () => {
      const nextCookies = await cookies();
      const nextHeaders = await headers();

      nextHeaders.set('x-workos-middleware', 'true');
      nextCookies.set('wos-session', 'foo', { domain: 'example.com' });

      await signOut();

      const sessionCookie = nextCookies.get('wos-session');
      expect(sessionCookie).toBeUndefined();
    });

    describe('when given a `returnTo` parameter', () => {
      it('passes the `returnTo` through to the `getLogoutUrl` call', async () => {
        jest
          .spyOn(workos.userManagement, 'getLogoutUrl')
          .mockReturnValue('https://user-management-logout.com/signed-out');
        const mockSession = {
          accessToken: await generateTestToken(),
          sessionId: 'session_123',
        } as const;

        const nextHeaders = await headers();
        nextHeaders.set(
          'x-workos-session',
          await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
        );

        nextHeaders.set('x-workos-middleware', 'true');

        await signOut({ returnTo: 'https://example.com/signed-out' });

        expect(redirect).toHaveBeenCalledTimes(1);
        expect(redirect).toHaveBeenCalledWith('https://user-management-logout.com/signed-out');
        expect(workos.userManagement.getLogoutUrl).toHaveBeenCalledWith(
          expect.objectContaining({
            returnTo: 'https://example.com/signed-out',
          }),
        );
      });

      describe('when there is no session', () => {
        it('returns to the `returnTo`', async () => {
          const nextHeaders = await headers();

          nextHeaders.set('x-workos-middleware', 'true');

          await signOut({ returnTo: 'https://example.com/signed-out' });

          expect(redirect).toHaveBeenCalledTimes(1);
          expect(redirect).toHaveBeenCalledWith('https://example.com/signed-out');
        });
      });
    });
  });
});



================================================
FILE: __tests__/authkit-callback-route.spec.ts
================================================
import { getWorkOS } from '../src/workos.js';
import { handleAuth } from '../src/authkit-callback-route.js';
import { NextRequest, NextResponse } from 'next/server';

// Mocked in jest.setup.ts
import { cookies, headers } from 'next/headers';

// Mock dependencies
const fakeWorkosInstance = {
  userManagement: {
    authenticateWithCode: jest.fn(),
    getJwksUrl: jest.fn(() => 'https://api.workos.com/sso/jwks/client_1234567890'),
  },
};

jest.mock('../src/workos', () => ({
  getWorkOS: jest.fn(() => fakeWorkosInstance),
}));

describe('authkit-callback-route', () => {
  const workos = getWorkOS();
  const mockAuthResponse = {
    accessToken: 'access123',
    refreshToken: 'refresh123',
    user: {
      id: 'user_123',
      email: 'test@example.com',
      emailVerified: true,
      profilePictureUrl: 'https://example.com/photo.jpg',
      firstName: 'Test',
      lastName: 'User',
      object: 'user' as const,
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-01T00:00:00Z',
      lastSignInAt: '2024-01-01T00:00:00Z',
      externalId: null,
      metadata: {},
    },
    oauthTokens: {
      accessToken: 'access123',
      refreshToken: 'refresh123',
      expiresAt: 1719811200,
      scopes: ['foo', 'bar'],
    },
  };

  describe('handleAuth', () => {
    let request: NextRequest;

    beforeAll(() => {
      // Silence console.error during tests
      jest.spyOn(console, 'error').mockImplementation(() => {});
    });

    beforeEach(async () => {
      // Reset all mocks
      jest.clearAllMocks();

      // Create a new request with searchParams
      request = new NextRequest(new URL('http://example.com/callback'));

      // Reset the cookie store
      const nextCookies = await cookies();
      // @ts-expect-error - _reset is part of the mock
      nextCookies._reset();

      const nextHeaders = await headers();
      // @ts-expect-error - _reset is part of the mock
      nextHeaders._reset();
    });

    it('should handle successful authentication', async () => {
      jest.mocked(workos.userManagement.authenticateWithCode).mockResolvedValue(mockAuthResponse);

      // Set up request with code
      request.nextUrl.searchParams.set('code', 'test-code');

      const handler = handleAuth();
      const response = await handler(request);

      expect(workos.userManagement.authenticateWithCode).toHaveBeenCalledWith({
        clientId: process.env.WORKOS_CLIENT_ID,
        code: 'test-code',
      });
      expect(response).toBeInstanceOf(NextResponse);
    });

    it('should handle authentication failure', async () => {
      // Mock authentication failure
      (workos.userManagement.authenticateWithCode as jest.Mock).mockRejectedValue(new Error('Auth failed'));

      request.nextUrl.searchParams.set('code', 'invalid-code');

      const handler = handleAuth();
      const response = await handler(request);

      expect(response.status).toBe(500);
      const data = await response.json();
      expect(data.error.message).toBe('Something went wrong');
    });

    it('should handle authentication failure if a non-Error object is thrown', async () => {
      // Mock authentication failure
      jest.mocked(workos.userManagement.authenticateWithCode).mockRejectedValue('Auth failed');

      request.nextUrl.searchParams.set('code', 'invalid-code');

      const handler = handleAuth();
      const response = await handler(request);

      expect(response.status).toBe(500);
      const data = await response.json();
      expect(data.error.message).toBe('Something went wrong');
    });

    it('should handle authentication failure with custom onError handler', async () => {
      // Mock authentication failure
      jest.mocked(workos.userManagement.authenticateWithCode).mockRejectedValue('Auth failed');
      request.nextUrl.searchParams.set('code', 'invalid-code');

      const handler = handleAuth({
        onError: ({ error }) => {
          return new Response(JSON.stringify({ error: { message: 'Custom error' } }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' },
          });
        },
      });
      const response = await handler(request);

      expect(response.status).toBe(500);
      const data = await response.json();
      expect(data.error.message).toBe('Custom error');
    });

    it('should handle missing code parameter', async () => {
      const handler = handleAuth();
      const response = await handler(request);

      expect(response.status).toBe(500);
      const data = await response.json();
      expect(data.error.message).toBe('Something went wrong');
    });

    it('should respect custom returnPathname', async () => {
      jest.mocked(workos.userManagement.authenticateWithCode).mockResolvedValue(mockAuthResponse);

      request.nextUrl.searchParams.set('code', 'test-code');

      const handler = handleAuth({ returnPathname: '/dashboard' });
      const response = await handler(request);

      expect(response.headers.get('Location')).toContain('/dashboard');
    });

    it('should handle state parameter with returnPathname', async () => {
      jest.mocked(workos.userManagement.authenticateWithCode).mockResolvedValue(mockAuthResponse);

      const state = btoa(JSON.stringify({ returnPathname: '/custom-path' }));
      request.nextUrl.searchParams.set('code', 'test-code');
      request.nextUrl.searchParams.set('state', state);

      const handler = handleAuth();
      const response = await handler(request);

      expect(response.headers.get('Location')).toContain('/custom-path');
    });

    it('should extract custom search params from returnPathname', async () => {
      jest.mocked(workos.userManagement.authenticateWithCode).mockResolvedValue(mockAuthResponse);

      const state = btoa(JSON.stringify({ returnPathname: '/custom-path?foo=bar&baz=qux' }));
      request.nextUrl.searchParams.set('code', 'test-code');
      request.nextUrl.searchParams.set('state', state);

      const handler = handleAuth();
      const response = await handler(request);

      expect(response.headers.get('Location')).toContain('/custom-path?foo=bar&baz=qux');
    });

    it('should use Response if NextResponse.redirect is not available', async () => {
      const originalRedirect = NextResponse.redirect;
      (NextResponse as Partial<typeof NextResponse>).redirect = undefined;

      jest.mocked(workos.userManagement.authenticateWithCode).mockResolvedValue(mockAuthResponse);

      // Set up request with code
      request.nextUrl.searchParams.set('code', 'test-code');

      const handler = handleAuth();
      const response = await handler(request);

      expect(response).toBeInstanceOf(Response);

      // Restore the original redirect method
      (NextResponse as Partial<typeof NextResponse>).redirect = originalRedirect;
    });

    it('should use Response if NextResponse.json is not available', async () => {
      const originalJson = NextResponse.json;
      (NextResponse as Partial<typeof NextResponse>).json = undefined;

      const handler = handleAuth();
      const response = await handler(request);

      expect(response).toBeInstanceOf(Response);

      // Restore the original json method
      (NextResponse as Partial<typeof NextResponse>).json = originalJson;
    });

    it('should throw an error if baseURL is provided but invalid', async () => {
      expect(() => handleAuth({ baseURL: 'invalid-url' })).toThrow('Invalid baseURL: invalid-url');
    });

    it('should use baseURL if provided', async () => {
      jest.mocked(workos.userManagement.authenticateWithCode).mockResolvedValue(mockAuthResponse);

      // Set up request with code
      request.nextUrl.searchParams.set('code', 'test-code');

      const handler = handleAuth({ baseURL: 'https://base.com' });
      const response = await handler(request);

      expect(response.headers.get('Location')).toContain('https://base.com');
    });

    it('should throw an error if response is missing tokens', async () => {
      const mockAuthResponse = {
        user: { id: 'user_123' },
      };

      (workos.userManagement.authenticateWithCode as jest.Mock).mockResolvedValue(mockAuthResponse);

      // Set up request with code
      request.nextUrl.searchParams.set('code', 'test-code');

      const handler = handleAuth();
      const response = await handler(request);

      expect(response.status).toBe(500);
    });

    it('should call onSuccess if provided', async () => {
      jest.mocked(workos.userManagement.authenticateWithCode).mockResolvedValue(mockAuthResponse);

      // Set up request with code
      request.nextUrl.searchParams.set('code', 'test-code');

      const onSuccess = jest.fn();
      const handler = handleAuth({ onSuccess: onSuccess });
      await handler(request);

      expect(onSuccess).toHaveBeenCalledWith(mockAuthResponse);
    });
  });
});



================================================
FILE: __tests__/authkit-provider.spec.tsx
================================================
import React from 'react';
import { render, waitFor, act } from '@testing-library/react';
import '@testing-library/jest-dom';
import { AuthKitProvider, useAuth } from '../src/components/authkit-provider.js';
import {
  checkSessionAction,
  getAuthAction,
  refreshAuthAction,
  handleSignOutAction,
  switchToOrganizationAction,
} from '../src/actions.js';

jest.mock('../src/actions', () => ({
  checkSessionAction: jest.fn(),
  getAuthAction: jest.fn(),
  refreshAuthAction: jest.fn(),
  handleSignOutAction: jest.fn(),
  switchToOrganizationAction: jest.fn(),
}));

describe('AuthKitProvider', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should render children', async () => {
    const { getByText } = await act(async () => {
      return render(
        <AuthKitProvider>
          <div>Test Child</div>
        </AuthKitProvider>,
      );
    });

    expect(getByText('Test Child')).toBeInTheDocument();
  });

  it('should do nothing if onSessionExpired is false', async () => {
    jest.spyOn(window, 'addEventListener');

    await act(async () => {
      render(
        <AuthKitProvider onSessionExpired={false}>
          <div>Test Child</div>
        </AuthKitProvider>,
      );
    });

    // expect window to not have an event listener
    expect(window.addEventListener).not.toHaveBeenCalled();
  });

  it('should call onSessionExpired when session is expired', async () => {
    (checkSessionAction as jest.Mock).mockRejectedValueOnce(new Error('Failed to fetch'));
    const onSessionExpired = jest.fn();

    render(
      <AuthKitProvider onSessionExpired={onSessionExpired}>
        <div>Test Child</div>
      </AuthKitProvider>,
    );

    act(() => {
      // Simulate visibility change
      window.dispatchEvent(new Event('visibilitychange'));
    });

    await waitFor(() => {
      expect(onSessionExpired).toHaveBeenCalled();
    });
  });

  it('should only call onSessionExpired once if multiple visibility changes occur', async () => {
    (checkSessionAction as jest.Mock).mockRejectedValueOnce(new Error('Failed to fetch'));
    const onSessionExpired = jest.fn();

    render(
      <AuthKitProvider onSessionExpired={onSessionExpired}>
        <div>Test Child</div>
      </AuthKitProvider>,
    );

    act(() => {
      // Simulate visibility change twice
      window.dispatchEvent(new Event('visibilitychange'));
      window.dispatchEvent(new Event('visibilitychange'));
    });

    await waitFor(() => {
      expect(onSessionExpired).toHaveBeenCalledTimes(1);
    });
  });

  it('should pass through if checkSessionAction does not throw "Failed to fetch"', async () => {
    (checkSessionAction as jest.Mock).mockResolvedValueOnce(false);

    const onSessionExpired = jest.fn();

    render(
      <AuthKitProvider onSessionExpired={onSessionExpired}>
        <div>Test Child</div>
      </AuthKitProvider>,
    );

    act(() => {
      // Simulate visibility change
      window.dispatchEvent(new Event('visibilitychange'));
    });

    await waitFor(() => {
      expect(onSessionExpired).not.toHaveBeenCalled();
    });
  });

  it('should reload the page when session is expired and no onSessionExpired handler is provided', async () => {
    (checkSessionAction as jest.Mock).mockRejectedValueOnce(new Error('Failed to fetch'));

    const originalLocation = window.location;

    // @ts-expect-error - we're deleting the property to test the mock
    delete window.location;

    window.location = { ...window.location, reload: jest.fn() };

    render(
      <AuthKitProvider>
        <div>Test Child</div>
      </AuthKitProvider>,
    );

    act(() => {
      // Simulate visibility change
      window.dispatchEvent(new Event('visibilitychange'));
    });

    await waitFor(() => {
      expect(window.location.reload).toHaveBeenCalled();
    });

    // Restore original reload function
    window.location = originalLocation;
  });

  it('should not call onSessionExpired or reload the page if session is valid', async () => {
    (checkSessionAction as jest.Mock).mockResolvedValueOnce(true);
    const onSessionExpired = jest.fn();

    const originalLocation = window.location;

    // @ts-expect-error - we're deleting the property to test the mock
    delete window.location;

    window.location = { ...window.location, reload: jest.fn() };

    render(
      <AuthKitProvider onSessionExpired={onSessionExpired}>
        <div>Test Child</div>
      </AuthKitProvider>,
    );

    act(() => {
      // Simulate visibility change
      window.dispatchEvent(new Event('visibilitychange'));
    });

    await waitFor(() => {
      expect(onSessionExpired).not.toHaveBeenCalled();
      expect(window.location.reload).not.toHaveBeenCalled();
    });

    window.location = originalLocation;
  });
});

describe('useAuth', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should call getAuth when a user is not returned when ensureSignedIn is true', async () => {
    // First and second calls return no user, second call returns a user
    (getAuthAction as jest.Mock)
      .mockResolvedValueOnce({ user: null, loading: true })
      .mockResolvedValueOnce({ user: { email: 'test@example.com' }, loading: false });

    const TestComponent = () => {
      const auth = useAuth({ ensureSignedIn: true });
      return <div data-testid="email">{auth.user?.email}</div>;
    };

    const { getByTestId } = render(
      <AuthKitProvider>
        <TestComponent />
      </AuthKitProvider>,
    );

    await waitFor(() => {
      expect(getAuthAction).toHaveBeenCalledTimes(2);
      expect(getAuthAction).toHaveBeenLastCalledWith({ ensureSignedIn: true });
      expect(getByTestId('email')).toHaveTextContent('test@example.com');
    });
  });

  it('should throw error when used outside of AuthKitProvider', () => {
    const TestComponent = () => {
      const auth = useAuth();
      return <div>{auth.user?.email}</div>;
    };

    // Suppress console.error for this test since we expect an error
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

    expect(() => {
      render(<TestComponent />);
    }).toThrow('useAuth must be used within an AuthKitProvider');

    consoleSpy.mockRestore();
  });

  it('should provide auth context values when used within AuthKitProvider', async () => {
    (getAuthAction as jest.Mock).mockResolvedValueOnce({
      user: { email: 'test@example.com' },
      sessionId: 'test-session',
      organizationId: 'test-org',
      role: 'admin',
      permissions: ['read', 'write'],
      entitlements: ['feature1'],
      featureFlags: ['test-flag'],
      impersonator: { email: 'admin@example.com' },
    });

    const TestComponent = () => {
      const auth = useAuth();
      return (
        <div>
          <div data-testid="loading">{auth.loading.toString()}</div>
          <div data-testid="email">{auth.user?.email}</div>
          <div data-testid="session">{auth.sessionId}</div>
          <div data-testid="org">{auth.organizationId}</div>
        </div>
      );
    };

    const { getByTestId } = render(
      <AuthKitProvider>
        <TestComponent />
      </AuthKitProvider>,
    );

    // Initially loading
    expect(getByTestId('loading')).toHaveTextContent('true');

    // Wait for auth to load
    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('email')).toHaveTextContent('test@example.com');
      expect(getByTestId('session')).toHaveTextContent('test-session');
      expect(getByTestId('org')).toHaveTextContent('test-org');
    });
  });

  it('should handle auth methods (getAuth and refreshAuth)', async () => {
    const mockAuth = {
      user: { email: 'test@example.com' },
      sessionId: 'test-session',
    };

    (getAuthAction as jest.Mock).mockResolvedValueOnce(mockAuth);
    (refreshAuthAction as jest.Mock).mockResolvedValueOnce({
      ...mockAuth,
      sessionId: 'new-session',
    });

    const TestComponent = () => {
      const auth = useAuth();
      return (
        <div>
          <div data-testid="session">{auth.sessionId}</div>
          <button onClick={() => auth.refreshAuth()}>Refresh</button>
        </div>
      );
    };

    const { getByTestId, getByRole } = render(
      <AuthKitProvider>
        <TestComponent />
      </AuthKitProvider>,
    );

    await waitFor(() => {
      expect(getByTestId('session')).toHaveTextContent('test-session');
    });

    // Test refresh
    act(() => {
      getByRole('button').click();
    });

    await waitFor(() => {
      expect(getByTestId('session')).toHaveTextContent('new-session');
    });
  });

  it('should handle switching organizations', async () => {
    const mockAuth = {
      user: { email: 'test@example.com' },
      sessionId: 'test-session',
      organizationId: 'new-org',
    };

    (getAuthAction as jest.Mock)
      .mockResolvedValue(mockAuth)
      .mockResolvedValueOnce({ ...mockAuth, organizationId: 'old-org' });
    (switchToOrganizationAction as jest.Mock).mockResolvedValueOnce(mockAuth);

    const TestComponent = () => {
      const auth = useAuth();
      return (
        <div>
          <div data-testid="org">{auth.organizationId}</div>
          <button onClick={async () => await auth.switchToOrganization('test-org')}>Switch Organization</button>
        </div>
      );
    };

    const { getByTestId, getByRole } = render(
      <AuthKitProvider>
        <TestComponent />
      </AuthKitProvider>,
    );

    await waitFor(() => {
      expect(getByTestId('org')).toHaveTextContent('old-org');
    });

    // Test refresh
    act(() => {
      getByRole('button').click();
    });

    await waitFor(() => {
      expect(getByTestId('org')).toHaveTextContent('new-org');
    });
  });

  it('should receive an error when refreshAuth fails with an error', async () => {
    (refreshAuthAction as jest.Mock).mockRejectedValueOnce(new Error('Refresh failed'));

    let error: string | undefined;

    const TestComponent = () => {
      const auth = useAuth();
      return (
        <div>
          <div data-testid="session">{auth.sessionId}</div>
          <button
            onClick={async () => {
              const result = await auth.refreshAuth();
              error = result?.error;
            }}
          >
            Refresh
          </button>
        </div>
      );
    };

    const { getByRole } = render(
      <AuthKitProvider>
        <TestComponent />
      </AuthKitProvider>,
    );

    act(() => {
      getByRole('button').click();
    });

    await waitFor(() => {
      expect(error).toBe('Refresh failed');
    });
  });

  it('should receive an error when refreshAuth fails with a string error', async () => {
    (refreshAuthAction as jest.Mock).mockRejectedValueOnce('Refresh failed');

    let error: string | undefined;

    const TestComponent = () => {
      const auth = useAuth();
      return (
        <div>
          <div data-testid="session">{auth.sessionId}</div>
          <button
            onClick={async () => {
              const result = await auth.refreshAuth();
              error = result?.error;
            }}
          >
            Refresh
          </button>
        </div>
      );
    };

    const { getByRole } = render(
      <AuthKitProvider>
        <TestComponent />
      </AuthKitProvider>,
    );

    act(() => {
      getByRole('button').click();
    });

    await waitFor(() => {
      expect(error).toBe('Refresh failed');
    });
  });

  it('should call handleSignOutAction when signOut is called', async () => {
    (handleSignOutAction as jest.Mock).mockResolvedValueOnce({});

    const TestComponent = () => {
      const auth = useAuth();
      return (
        <div>
          <div data-testid="session">{auth.sessionId}</div>
          <button onClick={() => auth.signOut()}>Sign out</button>
        </div>
      );
    };

    const { getByRole } = render(
      <AuthKitProvider>
        <TestComponent />
      </AuthKitProvider>,
    );

    await act(async () => {
      getByRole('button').click();
    });

    expect(handleSignOutAction).toHaveBeenCalled();
  });

  it('should pass returnTo parameter to handleSignOutAction', async () => {
    (handleSignOutAction as jest.Mock).mockResolvedValueOnce({});

    const TestComponent = () => {
      const auth = useAuth();
      return (
        <div>
          <div data-testid="session">{auth.sessionId}</div>
          <button onClick={() => auth.signOut({ returnTo: '/home' })}>Sign out</button>
        </div>
      );
    };

    const { getByRole } = render(
      <AuthKitProvider>
        <TestComponent />
      </AuthKitProvider>,
    );

    await act(async () => {
      getByRole('button').click();
    });

    expect(handleSignOutAction).toHaveBeenCalledWith({ returnTo: '/home' });
  });
});



================================================
FILE: __tests__/button.spec.tsx
================================================
import React from 'react';
import { render } from '@testing-library/react';
import '@testing-library/jest-dom';
import { Button } from '../src/components/button.js';

describe('Button', () => {
  it('should render with default props', () => {
    const { getByRole } = render(<Button>Click me</Button>);
    const button = getByRole('button');

    expect(button).toBeInTheDocument();
    expect(button).toHaveTextContent('Click me');
    expect(button).toHaveAttribute('type', 'button');
  });

  it('should forward ref correctly', () => {
    const ref = React.createRef<HTMLButtonElement>();
    render(<Button ref={ref}>Click me</Button>);

    expect(ref.current).toBeInstanceOf(HTMLButtonElement);
  });

  it('should merge custom styles with default styles', () => {
    const { getByRole } = render(<Button style={{ backgroundColor: 'red' }}>Click me</Button>);
    const button = getByRole('button');

    expect(button).toHaveStyle({
      backgroundColor: 'red',
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
    });
  });

  it('should pass through additional props', () => {
    const { getByRole } = render(
      <Button data-testid="test-button" aria-label="Test Button">
        Click me
      </Button>,
    );
    const button = getByRole('button');

    expect(button).toHaveAttribute('data-testid', 'test-button');
    expect(button).toHaveAttribute('aria-label', 'Test Button');
  });
});



================================================
FILE: __tests__/cookie.spec.ts
================================================
import { describe, it, expect } from '@jest/globals';

// Mock at the top of the file
jest.mock('../src/env-variables');

describe('cookie.ts', () => {
  beforeEach(() => {
    // Clear all mocks before each test
    jest.clearAllMocks();
    // Reset modules
    jest.resetModules();
  });

  describe('getCookieOptions', () => {
    it('should return the default cookie options', async () => {
      const { getCookieOptions } = await import('../src/cookie');

      const options = getCookieOptions();
      expect(options).toEqual(
        expect.objectContaining({
          path: '/',
          httpOnly: true,
          secure: false,
          sameSite: 'lax',
          maxAge: 400 * 24 * 60 * 60,
          domain: 'example.com',
        }),
      );
    });

    it('should return the cookie options with custom values', async () => {
      // Import the mocked module
      const envVars = await import('../src/env-variables');

      // Set the mock values
      Object.defineProperty(envVars, 'WORKOS_COOKIE_MAX_AGE', { value: '1000' });
      Object.defineProperty(envVars, 'WORKOS_COOKIE_DOMAIN', { value: 'foobar.com' });

      const { getCookieOptions } = await import('../src/cookie');
      const options = getCookieOptions('http://example.com');

      expect(options).toEqual(
        expect.objectContaining({
          secure: false,
          maxAge: 1000,
          domain: 'foobar.com',
        }),
      );

      Object.defineProperty(envVars, 'WORKOS_COOKIE_DOMAIN', { value: '' });

      const options2 = getCookieOptions('http://example.com');
      expect(options2).toEqual(
        expect.objectContaining({
          secure: false,
          maxAge: 1000,
          domain: '',
        }),
      );

      const options3 = getCookieOptions('https://example.com', true);

      expect(options3).toEqual(expect.stringContaining('Domain='));
    });

    it('should return the cookie options with expired set to true', async () => {
      const { getCookieOptions } = await import('../src/cookie');
      const options = getCookieOptions('http://example.com', false, true);
      expect(options).toEqual(expect.objectContaining({ maxAge: 0 }));
    });

    it('should return the cookie options as a string', async () => {
      const { getCookieOptions } = await import('../src/cookie');
      const options = getCookieOptions('http://example.com', true, false);
      expect(options).toEqual(
        expect.stringContaining('Path=/; HttpOnly; Secure=false; SameSite=lax; Max-Age=34560000; Domain=example.com'),
      );

      const options2 = getCookieOptions('https://example.com', true, true);
      expect(options2).toEqual(
        expect.stringContaining('Path=/; HttpOnly; Secure=true; SameSite=lax; Max-Age=0; Domain=example.com'),
      );
    });

    it('allows the sameSite config to be set by the WORKOS_COOKIE_SAMESITE env variable', async () => {
      const envVars = await import('../src/env-variables');
      Object.defineProperty(envVars, 'WORKOS_COOKIE_SAMESITE', { value: 'none' });

      const { getCookieOptions } = await import('../src/cookie');
      const options = getCookieOptions('http://example.com');
      expect(options).toEqual(expect.objectContaining({ sameSite: 'none' }));
    });

    it('throws an error if the sameSite value is invalid', async () => {
      const envVars = await import('../src/env-variables');
      Object.defineProperty(envVars, 'WORKOS_COOKIE_SAMESITE', { value: 'invalid' });

      const { getCookieOptions } = await import('../src/cookie');
      expect(() => getCookieOptions('http://example.com')).toThrow('Invalid SameSite value: invalid');
    });
  });
});



================================================
FILE: __tests__/get-authorization-url.spec.ts
================================================
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { getAuthorizationUrl } from '../src/get-authorization-url.js';
import { headers } from 'next/headers';
import { getWorkOS } from '../src/workos.js';

jest.mock('next/headers');

// Mock dependencies
const fakeWorkosInstance = {
  userManagement: {
    getAuthorizationUrl: jest.fn(),
  },
};

jest.mock('../src/workos', () => ({
  getWorkOS: jest.fn(() => fakeWorkosInstance),
}));

describe('getAuthorizationUrl', () => {
  const workos = getWorkOS();
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('uses x-redirect-uri header when redirectUri option is not provided', async () => {
    const nextHeaders = await headers();
    nextHeaders.set('x-redirect-uri', 'http://test-redirect.com');

    // Mock workos.userManagement.getAuthorizationUrl
    jest.mocked(workos.userManagement.getAuthorizationUrl).mockReturnValue('mock-url');

    await getAuthorizationUrl({});

    expect(workos.userManagement.getAuthorizationUrl).toHaveBeenCalledWith(
      expect.objectContaining({
        redirectUri: 'http://test-redirect.com',
      }),
    );
  });

  it('works when called with no arguments', async () => {
    jest.mocked(workos.userManagement.getAuthorizationUrl).mockReturnValue('mock-url');

    await getAuthorizationUrl(); // Call with no arguments

    expect(workos.userManagement.getAuthorizationUrl).toHaveBeenCalled();
  });
});



================================================
FILE: __tests__/impersonation.spec.tsx
================================================
import { render, act, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import { Impersonation } from '../src/components/impersonation.js';
import { useAuth } from '../src/components/authkit-provider.js';
import { getOrganizationAction } from '../src/actions.js';
import * as React from 'react';
import { handleSignOutAction } from '../src/actions.js';

// Mock the useAuth hook
jest.mock('../src/components/authkit-provider', () => ({
  useAuth: jest.fn(),
}));

// Mock the getOrganizationAction
jest.mock('../src/actions', () => ({
  getOrganizationAction: jest.fn(),
  handleSignOutAction: jest.fn(),
}));

describe('Impersonation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return null if not impersonating', () => {
    (useAuth as jest.Mock).mockReturnValue({
      impersonator: null,
      user: { id: '123', email: 'user@example.com' },
      organizationId: null,
      loading: false,
    });

    const { container } = render(<Impersonation />);
    expect(container).toBeEmptyDOMElement();
  });

  it('should return null if loading', () => {
    (useAuth as jest.Mock).mockReturnValue({
      impersonator: { email: 'admin@example.com' },
      user: { id: '123', email: 'user@example.com' },
      organizationId: null,
      loading: true,
    });

    const { container } = render(<Impersonation />);
    expect(container).toBeEmptyDOMElement();
  });

  it('should render impersonation banner when impersonating', () => {
    (useAuth as jest.Mock).mockReturnValue({
      impersonator: { email: 'admin@example.com' },
      user: { id: '123', email: 'user@example.com' },
      organizationId: null,
      loading: false,
    });

    const { container } = render(<Impersonation />);
    expect(container.querySelector('[data-workos-impersonation-root]')).toBeInTheDocument();
  });

  it('should render with organization info when organizationId is provided', async () => {
    (useAuth as jest.Mock).mockReturnValue({
      impersonator: { email: 'admin@example.com' },
      user: { id: '123', email: 'user@example.com' },
      organizationId: 'org_123',
      loading: false,
    });

    (getOrganizationAction as jest.Mock).mockResolvedValue({
      id: 'org_123',
      name: 'Test Org',
    });

    const { container } = await act(async () => {
      return render(<Impersonation />);
    });

    expect(container.querySelector('[data-workos-impersonation-root]')).toBeInTheDocument();
  });

  it('should render at the bottom by default', () => {
    (useAuth as jest.Mock).mockReturnValue({
      impersonator: { email: 'admin@example.com' },
      user: { id: '123', email: 'user@example.com' },
      organizationId: null,
      loading: false,
    });

    const { container } = render(<Impersonation />);
    const banner = container.querySelector('[data-workos-impersonation-root] > div:nth-child(2)');
    expect(banner).toHaveStyle({ bottom: 'var(--wi-s)' });
  });

  it('should render at the top when side prop is "top"', () => {
    (useAuth as jest.Mock).mockReturnValue({
      impersonator: { email: 'admin@example.com' },
      user: { id: '123', email: 'user@example.com' },
      organizationId: null,
      loading: false,
    });

    const { container } = render(<Impersonation side="top" />);
    const banner = container.querySelector('[data-workos-impersonation-root] > div:nth-child(2)');
    expect(banner).toHaveStyle({ top: 'var(--wi-s)' });
  });

  it('should merge custom styles with default styles', () => {
    (useAuth as jest.Mock).mockReturnValue({
      impersonator: { email: 'admin@example.com' },
      user: { id: '123', email: 'user@example.com' },
      organizationId: null,
      loading: false,
    });

    const customStyle = { backgroundColor: 'red' };
    const { container } = render(<Impersonation style={customStyle} />);
    const root = container.querySelector('[data-workos-impersonation-root]');
    expect(root).toHaveStyle({ backgroundColor: 'red' });
  });

  it('should should sign out when the Stop button is called', async () => {
    (useAuth as jest.Mock).mockReturnValue({
      impersonator: { email: 'admin@example.com' },
      user: { id: '123', email: 'user@example.com' },
      organizationId: null,
      loading: false,
    });

    render(<Impersonation />);
    const stopButton = await screen.findByText('Stop');
    stopButton.click();
    expect(handleSignOutAction).toHaveBeenCalled();
  });
});



================================================
FILE: __tests__/min-max-button.spec.tsx
================================================
import { render, act } from '@testing-library/react';
import { MinMaxButton } from '../src/components/min-max-button.js';
import * as React from 'react';
import '@testing-library/jest-dom';

describe('MinMaxButton', () => {
  beforeEach(() => {
    // Create the root element before each test
    const root = document.createElement('div');
    root.setAttribute('data-workos-impersonation-root', '');
    document.body.appendChild(root);
  });

  afterEach(() => {
    // Clean up after each test
    document.body.innerHTML = '';
  });

  it('sets minimized value when clicked', () => {
    const { getByRole } = render(<MinMaxButton minimizedValue="1">Minimize</MinMaxButton>);

    act(() => {
      getByRole('button').click();
    });

    const root = document.querySelector('[data-workos-impersonation-root]');
    expect(root).toHaveStyle({ '--wi-minimized': '1' });
  });

  it('does nothing if root is undefined', () => {
    const { getByRole } = render(<MinMaxButton minimizedValue="1">Minimize</MinMaxButton>);

    const root = document.querySelector('[data-workos-impersonation-root]');

    // Mock querySelector to return null for this test
    jest.spyOn(document, 'querySelector').mockReturnValue(null);

    act(() => {
      getByRole('button').click();
    });

    expect(root).not.toHaveStyle({ '--wi-minimized': '1' });
  });

  it('renders children correctly', () => {
    const { getByText } = render(<MinMaxButton minimizedValue="0">Test Child</MinMaxButton>);

    expect(getByText('Test Child')).toBeInTheDocument();
  });

  it('applies correct default styling', () => {
    const { getByRole } = render(<MinMaxButton minimizedValue="0">Test</MinMaxButton>);

    const button = getByRole('button');
    expect(button).toHaveStyle({
      padding: 0,
      width: '1.714em',
    });
  });
});



================================================
FILE: __tests__/session.spec.ts
================================================
import { NextRequest, NextResponse } from 'next/server';
import { cookies, headers } from 'next/headers';
import { redirect } from 'next/navigation';
import { generateTestToken } from './test-helpers.js';
import { withAuth, updateSession, refreshSession, updateSessionMiddleware, getTokenClaims } from '../src/session.js';
import { getWorkOS } from '../src/workos.js';
import * as envVariables from '../src/env-variables.js';

import { jwtVerify } from 'jose';
import { sealData } from 'iron-session';
import { User } from '@workos-inc/node';

jest.mock('jose', () => ({
  jwtVerify: jest.fn(),
  createRemoteJWKSet: jest.fn(),
  SignJWT: jest.requireActual('jose').SignJWT,
  decodeJwt: jest.requireActual('jose').decodeJwt,
}));

// logging is disabled by default, flip this to true to still have logs in the console
const DEBUG = false;

const workos = getWorkOS();

describe('session.ts', () => {
  const mockSession = {
    accessToken: 'access-token',
    oauthTokens: undefined,
    sessionId: 'session_123',
    organizationId: 'org_123',
    role: 'member',
    permissions: ['posts:create', 'posts:delete'],
    entitlements: ['audit-logs'],
    featureFlags: ['device-authorization-grant'],
    impersonator: undefined,
    user: {
      object: 'user',
      id: 'user_123',
      email: 'test@example.com',
      emailVerified: true,
      profilePictureUrl: null,
      firstName: null,
      lastName: null,
      createdAt: '2024-01-01',
      updatedAt: '2024-01-01',
    } as User,
  };

  let consoleLogSpy: jest.SpyInstance;

  beforeEach(async () => {
    // Clear all mocks between tests
    jest.clearAllMocks();

    // Reset the cookie store
    const nextCookies = await cookies();
    // @ts-expect-error - _reset is part of the mock
    nextCookies._reset();

    const nextHeaders = await headers();
    // @ts-expect-error - _reset is part of the mock
    nextHeaders._reset();
    nextHeaders.set('x-workos-middleware', 'true');

    (jwtVerify as jest.Mock).mockReset();

    consoleLogSpy = jest.spyOn(console, 'log').mockImplementation((...args) => {
      if (DEBUG) {
        console.info(...args);
      }
    });
  });

  afterEach(() => {
    consoleLogSpy.mockRestore();
    jest.resetModules();
  });

  describe('withAuth', () => {
    it('should return user info when authenticated', async () => {
      mockSession.accessToken = await generateTestToken();

      const nextHeaders = await headers();

      nextHeaders.set(
        'x-workos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      const result = await withAuth();
      expect(result).toHaveProperty('user');
      expect(result.user).toEqual(mockSession.user);
    });

    it('should return null when user is not authenticated', async () => {
      const result = await withAuth();

      expect(result).toEqual({ user: null });
    });

    it('should redirect when ensureSignedIn is true and user is not authenticated', async () => {
      const nextHeaders = await headers();
      nextHeaders.set('x-url', 'https://example.com/protected');

      await withAuth({ ensureSignedIn: true });

      expect(redirect).toHaveBeenCalledTimes(1);
    });

    it('should throw an error if the route is not covered by the middleware', async () => {
      const nextHeaders = await headers();
      nextHeaders.delete('x-workos-middleware');
      nextHeaders.set('x-url', 'https://example.com/');

      await expect(async () => {
        await withAuth();
      }).rejects.toThrow(
        "You are calling 'withAuth' on https://example.com/ that isn’t covered by the AuthKit middleware. Make sure it is running on all paths you are calling 'withAuth' from by updating your middleware config in 'middleware.(js|ts)'.",
      );
    });

    it('should throw an error if the route is not covered by the middleware and there is no URL in the headers', async () => {
      const nextHeaders = await headers();
      nextHeaders.delete('x-workos-middleware');

      await expect(async () => {
        await withAuth({ ensureSignedIn: true });
      }).rejects.toThrow(
        "You are calling 'withAuth' on a route that isn’t covered by the AuthKit middleware. Make sure it is running on all paths you are calling 'withAuth' from by updating your middleware config in 'middleware.(js|ts)'.",
      );
    });

    it('should throw an error if the URL is not found in the headers', async () => {
      const nextHeaders = await headers();
      nextHeaders.delete('x-url');

      await expect(async () => {
        await withAuth({ ensureSignedIn: true });
      }).rejects.toThrow('No URL found in the headers');
    });

    it('should include any search parameters in the redirect URL', async () => {
      const nextHeaders = await headers();
      nextHeaders.set('x-url', 'https://example.com/protected?test=123');

      await withAuth({ ensureSignedIn: true });

      const pathname = encodeURIComponent(btoa(JSON.stringify({ returnPathname: '/protected?test=123' })));

      expect(redirect).toHaveBeenCalledWith(expect.stringContaining(pathname));
    });
  });

  describe('updateSessionMiddleware', () => {
    it('should throw an error if the redirect URI is not set', async () => {
      const originalWorkosRedirectUri = envVariables.WORKOS_REDIRECT_URI;

      jest.replaceProperty(envVariables, 'WORKOS_REDIRECT_URI', '');

      await expect(async () => {
        await updateSessionMiddleware(
          new NextRequest(new URL('http://example.com')),
          false,
          {
            enabled: false,
            unauthenticatedPaths: [],
          },
          '',
          [],
        );
      }).rejects.toThrow('You must provide a redirect URI in the AuthKit middleware or in the environment variables.');

      jest.replaceProperty(envVariables, 'WORKOS_REDIRECT_URI', originalWorkosRedirectUri);
    });

    it('should throw an error if the cookie password is not set', async () => {
      const originalWorkosCookiePassword = envVariables.WORKOS_COOKIE_PASSWORD;

      jest.replaceProperty(envVariables, 'WORKOS_COOKIE_PASSWORD', '');

      await expect(async () => {
        await updateSessionMiddleware(
          new NextRequest(new URL('http://example.com')),
          false,
          {
            enabled: false,
            unauthenticatedPaths: [],
          },
          '',
          [],
        );
      }).rejects.toThrow(
        'You must provide a valid cookie password that is at least 32 characters in the environment variables.',
      );

      jest.replaceProperty(envVariables, 'WORKOS_COOKIE_PASSWORD', originalWorkosCookiePassword);
    });

    it('should throw an error if the cookie password is less than 32 characters', async () => {
      const originalWorkosCookiePassword = envVariables.WORKOS_COOKIE_PASSWORD;

      jest.replaceProperty(envVariables, 'WORKOS_COOKIE_PASSWORD', 'short');

      await expect(async () => {
        await updateSessionMiddleware(
          new NextRequest(new URL('http://example.com')),
          false,
          {
            enabled: false,
            unauthenticatedPaths: [],
          },
          '',
          [],
        );
      }).rejects.toThrow(
        'You must provide a valid cookie password that is at least 32 characters in the environment variables.',
      );

      jest.replaceProperty(envVariables, 'WORKOS_COOKIE_PASSWORD', originalWorkosCookiePassword);
    });

    it('should return early if there is no session', async () => {
      const request = new NextRequest(new URL('http://example.com'));
      const result = await updateSessionMiddleware(
        request,
        false,
        {
          enabled: false,
          unauthenticatedPaths: [],
        },
        process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
        [],
      );

      expect(result).toBeInstanceOf(NextResponse);
      expect(result.status).toBe(200);
    });

    it('should return 200 if the session is valid', async () => {
      jest.spyOn(console, 'log').mockImplementation(() => {});

      const nextCookies = await cookies();
      nextCookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      (jwtVerify as jest.Mock).mockImplementation(() => {
        return true;
      });

      const request = new NextRequest(new URL('http://example.com'));
      const result = await updateSessionMiddleware(
        request,
        true,
        {
          enabled: false,
          unauthenticatedPaths: [],
        },
        process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
        [],
      );

      expect(result).toBeInstanceOf(NextResponse);
      expect(result.status).toBe(200);
    });

    it('should attempt to refresh the session when the access token is invalid', async () => {
      mockSession.accessToken = await generateTestToken({}, true);

      (jwtVerify as jest.Mock).mockImplementation(() => {
        throw new Error('Invalid token');
      });

      jest.spyOn(workos.userManagement, 'authenticateWithRefreshToken').mockResolvedValue({
        accessToken: await generateTestToken(),
        refreshToken: 'new-refresh-token',
        user: mockSession.user,
      });

      const request = new NextRequest(new URL('http://example.com'));

      request.cookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      const result = await updateSessionMiddleware(
        request,
        true,
        {
          enabled: false,
          unauthenticatedPaths: [],
        },
        process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
        [],
      );

      expect(result.status).toBe(200);
      expect(console.log).toHaveBeenCalledWith(
        `Session invalid. Refreshing access token that ends in ${mockSession.accessToken.slice(-10)}`,
      );
      expect(console.log).toHaveBeenCalledWith(expect.stringContaining('Session successfully refreshed'));
    });

    it('should delete the cookie when refreshing fails', async () => {
      jest.spyOn(console, 'log').mockImplementation(() => {});

      mockSession.accessToken = await generateTestToken({}, true);

      (jwtVerify as jest.Mock).mockImplementation(() => {
        throw new Error('Invalid token');
      });

      jest
        .spyOn(workos.userManagement, 'authenticateWithRefreshToken')
        .mockRejectedValue(new Error('Failed to refresh'));

      const request = new NextRequest(new URL('http://example.com'));

      request.cookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      const response = await updateSessionMiddleware(
        request,
        true,
        {
          enabled: false,
          unauthenticatedPaths: [],
        },
        process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
        [],
      );

      expect(response.status).toBe(200);
      expect(response.headers.get('Set-Cookie')).toContain('wos-session=;');
      expect(console.log).toHaveBeenCalledTimes(2);
      expect(console.log).toHaveBeenNthCalledWith(
        1,
        `Session invalid. Refreshing access token that ends in ${mockSession.accessToken.slice(-10)}`,
      );
      expect(console.log).toHaveBeenNthCalledWith(
        2,
        'Failed to refresh. Deleting cookie.',
        new Error('Failed to refresh'),
      );
    });

    describe('middleware auth', () => {
      it('should redirect unauthenticated users on protected routes', async () => {
        jest.spyOn(console, 'log').mockImplementation(() => {});

        const request = new NextRequest(new URL('http://example.com/protected'));
        const result = await updateSessionMiddleware(
          request,
          true,
          {
            enabled: true,
            unauthenticatedPaths: [],
          },
          process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
          [],
        );

        expect(result.status).toBe(307);
        expect(console.log).toHaveBeenCalledWith(
          'Unauthenticated user on protected route http://example.com/protected, redirecting to AuthKit',
        );
      });

      it('should use Response if NextResponse.redirect is not available', async () => {
        const originalRedirect = NextResponse.redirect;
        (NextResponse as Partial<typeof NextResponse>).redirect = undefined;

        const request = new NextRequest(new URL('http://example.com/protected'));
        const result = await updateSessionMiddleware(
          request,
          false,
          {
            enabled: true,
            unauthenticatedPaths: [],
          },
          process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
          [],
        );

        expect(result).toBeInstanceOf(Response);

        // Restore the original redirect method
        (NextResponse as Partial<typeof NextResponse>).redirect = originalRedirect;
      });

      it('should automatically add the redirect URI to unauthenticatedPaths when middleware is enabled', async () => {
        const request = new NextRequest(new URL('http://example.com/protected'));
        const result = await updateSessionMiddleware(
          request,
          false,
          {
            enabled: true,
            unauthenticatedPaths: [],
          },
          'http://example.com/protected',
          [],
        );

        expect(result.status).toBe(200);
      });

      it('should redirect unauthenticated users to sign up page on protected routes included in signUpPaths', async () => {
        const request = new NextRequest(new URL('http://example.com/protected-signup'));
        const result = await updateSessionMiddleware(
          request,
          false,
          {
            enabled: true,
            unauthenticatedPaths: [],
          },
          process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
          ['/protected-signup'],
        );

        expect(result.status).toBe(307);
        expect(result.headers.get('Location')).toContain('screen_hint=sign-up');
      });

      it('should set the sign up paths in the headers', async () => {
        const request = new NextRequest(new URL('http://example.com/protected-signup'));
        const result = await updateSessionMiddleware(
          request,
          false,
          {
            enabled: false,
            unauthenticatedPaths: [],
          },
          process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
          ['/protected-signup'],
        );

        expect(result.headers.get('x-sign-up-paths')).toBe('/protected-signup');
      });

      it('should allow logged out users on unauthenticated paths', async () => {
        const request = new NextRequest(new URL('http://example.com/unauthenticated'));
        const result = await updateSessionMiddleware(
          request,
          false,
          {
            enabled: true,
            unauthenticatedPaths: ['/unauthenticated'],
          },
          process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
          [],
        );

        expect(result.status).toBe(200);
      });

      it('should throw an error if the provided regex is invalid', async () => {
        const request = new NextRequest(new URL('http://example.com/invalid-regex'));
        await expect(async () => {
          await updateSessionMiddleware(
            request,
            false,
            {
              enabled: true,
              unauthenticatedPaths: ['[*'],
            },
            process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
            [],
          );
        }).rejects.toThrow();
      });

      it('should throw an error if the provided regex is invalid and a non-Error object is thrown', async () => {
        // Reset modules to ensure clean import state
        jest.resetModules();

        // Import first, then spy
        const pathToRegexp = await import('path-to-regexp');
        const parseSpy = jest.spyOn(pathToRegexp, 'parse').mockImplementation(() => {
          throw 'invalid regex';
        });

        // Import session after setting up the spy
        const { updateSessionMiddleware } = await import('../src/session.js');

        const request = new NextRequest(new URL('http://example.com/invalid-regex'));

        await expect(async () => {
          await updateSessionMiddleware(
            request,
            false,
            {
              enabled: true,
              unauthenticatedPaths: ['[*'],
            },
            process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
            [],
          );
        }).rejects.toThrow('Error parsing routes for middleware auth. Reason: invalid regex');

        // Verify the mock was called
        expect(parseSpy).toHaveBeenCalled();
      });

      it('should default to the WORKOS_REDIRECT_URI environment variable if no redirect URI is provided', async () => {
        const request = new NextRequest(new URL('http://example.com/protected'));
        const result = await updateSessionMiddleware(
          request,
          false,
          {
            enabled: true,
            unauthenticatedPaths: [],
          },
          '',
          [],
        );

        expect(result.status).toBe(307);
      });

      it('should delete the cookie and redirect when refreshing fails', async () => {
        jest.spyOn(console, 'log').mockImplementation(() => {});

        mockSession.accessToken = await generateTestToken({}, true);

        (jwtVerify as jest.Mock).mockImplementation(() => {
          throw new Error('Invalid token');
        });

        jest
          .spyOn(workos.userManagement, 'authenticateWithRefreshToken')
          .mockRejectedValue(new Error('Failed to refresh'));

        const request = new NextRequest(new URL('http://example.com'));

        request.cookies.set(
          'wos-session',
          await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
        );

        const response = await updateSessionMiddleware(
          request,
          true,
          {
            enabled: true,
            unauthenticatedPaths: [],
          },
          process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
          [],
        );

        expect(response.status).toBe(307);
        expect(response.headers.get('Set-Cookie')).toContain('wos-session=;');
        expect(console.log).toHaveBeenCalledTimes(3);
        expect(console.log).toHaveBeenNthCalledWith(
          1,
          `Session invalid. Refreshing access token that ends in ${mockSession.accessToken.slice(-10)}`,
        );
        expect(console.log).toHaveBeenNthCalledWith(
          2,
          'Failed to refresh. Deleting cookie.',
          new Error('Failed to refresh'),
        );

        expect(console.log).toHaveBeenNthCalledWith(
          3,
          'Unauthenticated user on protected route http://example.com/, redirecting to AuthKit',
        );
      });

      describe('sign up paths', () => {
        it('should redirect to sign up when unauthenticated user is on a sign up path', async () => {
          const request = new NextRequest(new URL('http://example.com/signup'));

          const result = await updateSessionMiddleware(
            request,
            false,
            {
              enabled: true,
              unauthenticatedPaths: [],
            },
            process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI as string,
            ['/signup'],
          );

          expect(result.status).toBe(307);
          expect(result.headers.get('Location')).toContain('screen_hint=sign-up');
        });

        it('should accept a sign up path as a string', async () => {
          const nextHeaders = await headers();
          nextHeaders.set('x-url', 'http://example.com/signup');
          nextHeaders.set('x-sign-up-paths', '/signup');

          await withAuth({ ensureSignedIn: true });
          expect(redirect).toHaveBeenCalledTimes(1);
          expect(redirect).toHaveBeenCalledWith(expect.stringContaining('screen_hint=sign-up'));
        });
      });
    });
  });

  describe('updateSession', () => {
    it('should return an authorization url if the session is invalid', async () => {
      const result = await updateSession(new NextRequest(new URL('http://example.com/protected')), {
        debug: true,
        screenHint: 'sign-up',
      });

      expect(result.authorizationUrl).toBeDefined();
      expect(result.authorizationUrl).toContain('screen_hint=sign-up');
      expect(result.session.user).toBeNull();
      expect(console.log).toHaveBeenCalledWith('No session found from cookie');
    });

    it('should return a session if the session is valid', async () => {
      const request = new NextRequest(new URL('http://example.com/protected'));
      request.cookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      const result = await updateSession(request);

      expect(result.session).toBeDefined();
    });

    it('should attempt to refresh an invalid session', async () => {
      // Setup invalid session
      mockSession.accessToken = await generateTestToken({}, true);

      // Mock token verification to fail
      (jwtVerify as jest.Mock).mockImplementation(() => {
        throw new Error('Invalid token');
      });

      // Mock successful refresh
      jest.spyOn(workos.userManagement, 'authenticateWithRefreshToken').mockResolvedValue({
        accessToken: await generateTestToken(),
        refreshToken: 'new-refresh-token',
        user: mockSession.user,
      });

      const request = new NextRequest(new URL('http://example.com/protected'));
      request.cookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      const response = await updateSession(request, {
        debug: true,
      });

      expect(response.session).toBeDefined();
      expect(response.session.user).toBeDefined();
      expect(console.log).toHaveBeenCalledWith(
        expect.stringContaining('Session invalid. Refreshing access token that ends in'),
      );
    });

    it('should handle refresh failure by returning auth URL', async () => {
      // Setup invalid session
      mockSession.accessToken = await generateTestToken({}, true);

      // Mock token verification to fail
      (jwtVerify as jest.Mock).mockImplementation(() => {
        throw new Error('Invalid token');
      });

      // Mock refresh failure
      jest.spyOn(workos.userManagement, 'authenticateWithRefreshToken').mockRejectedValue(new Error('Refresh failed'));

      const request = new NextRequest(new URL('http://example.com/protected'));
      request.cookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      const response = await updateSession(request, {
        debug: true,
      });

      expect(response.session.user).toBeNull();
      expect(response.authorizationUrl).toBeDefined();
      expect(console.log).toHaveBeenCalledWith('Failed to refresh. Deleting cookie.', expect.any(Error));
    });

    it('should call onSessionRefreshSuccess when refresh succeeds', async () => {
      // Setup invalid session
      mockSession.accessToken = await generateTestToken({}, true);

      // Mock token verification to fail
      (jwtVerify as jest.Mock).mockImplementation(() => {
        throw new Error('Invalid token');
      });

      const newAccessToken = await generateTestToken();
      const mockSuccessCallback = jest.fn();

      // Mock successful refresh
      jest.spyOn(workos.userManagement, 'authenticateWithRefreshToken').mockResolvedValue({
        accessToken: newAccessToken,
        refreshToken: 'new-refresh-token',
        user: mockSession.user,
      });

      const request = new NextRequest(new URL('http://example.com/protected'));
      request.cookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      await updateSession(request, {
        debug: true,
        onSessionRefreshSuccess: mockSuccessCallback,
      });

      expect(mockSuccessCallback).toHaveBeenCalledTimes(1);
      expect(mockSuccessCallback).toHaveBeenCalledWith({
        accessToken: newAccessToken,
        user: mockSession.user,
        impersonator: undefined,
        organizationId: 'org_123',
      });
    });

    it('should call onSessionRefreshError when refresh fails', async () => {
      // Setup invalid session
      mockSession.accessToken = await generateTestToken({}, true);

      // Mock token verification to fail
      (jwtVerify as jest.Mock).mockImplementation(() => {
        throw new Error('Invalid token');
      });

      const mockError = new Error('Refresh failed');
      const mockErrorCallback = jest.fn();

      // Mock refresh failure
      jest.spyOn(workos.userManagement, 'authenticateWithRefreshToken').mockRejectedValue(mockError);

      const request = new NextRequest(new URL('http://example.com/protected'));
      request.cookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      await updateSession(request, {
        debug: true,
        onSessionRefreshError: mockErrorCallback,
      });

      expect(mockErrorCallback).toHaveBeenCalledTimes(1);
      expect(mockErrorCallback).toHaveBeenCalledWith({
        error: mockError,
        request,
      });
    });
  });

  describe('refreshSession', () => {
    it('should refresh session successfully', async () => {
      jest.spyOn(workos.userManagement, 'authenticateWithRefreshToken').mockResolvedValue({
        accessToken: await generateTestToken(),
        refreshToken: 'new-refresh-token',
        user: mockSession.user,
      });

      jest
        .spyOn(workos.userManagement, 'getJwksUrl')
        .mockReturnValue('https://api.workos.com/sso/jwks/client_1234567890');

      const nextCookies = await cookies();
      nextCookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      const result = await refreshSession({ ensureSignedIn: false });

      expect(result).toHaveProperty('user');
      expect(result).toHaveProperty('accessToken');
    });

    it('should return null user when no session exists', async () => {
      const result = await refreshSession({ ensureSignedIn: false });
      expect(result).toEqual({ user: null });
    });

    it('should redirect to sign in when ensureSignedIn is true and no session exists', async () => {
      const nextHeaders = await headers();
      nextHeaders.set('x-url', 'http://example.com/protected');

      const response = await refreshSession({ ensureSignedIn: true });

      expect(response).toEqual({ user: null });
      expect(redirect).toHaveBeenCalledTimes(1);
    });

    it('should use the organizationId provided in the options', async () => {
      const nextCookies = await cookies();
      nextCookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );

      jest.spyOn(workos.userManagement, 'authenticateWithRefreshToken').mockResolvedValue({
        accessToken: await generateTestToken({ org_id: 'org_456' }),
        refreshToken: 'new-refresh-token',
        user: mockSession.user,
      });

      jest
        .spyOn(workos.userManagement, 'getJwksUrl')
        .mockReturnValue('https://api.workos.com/sso/jwks/client_1234567890');

      const result = await refreshSession({ organizationId: 'org_456' });

      expect(result).toHaveProperty('user');
      expect(result.organizationId).toBe('org_456');
    });

    it('throws if authenticateWithRefreshToken fails with string', async () => {
      const nextCookies = await cookies();
      nextCookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );
      jest.spyOn(workos.userManagement, 'authenticateWithRefreshToken').mockRejectedValue('fail');
      expect(refreshSession({ ensureSignedIn: false })).rejects.toThrow('fail');
    });

    it('throws if authenticateWithRefreshToken fails with error', async () => {
      const nextCookies = await cookies();
      nextCookies.set(
        'wos-session',
        await sealData(mockSession, { password: process.env.WORKOS_COOKIE_PASSWORD as string }),
      );
      jest.spyOn(workos.userManagement, 'authenticateWithRefreshToken').mockRejectedValue(new Error('error'));
      await expect(refreshSession()).rejects.toThrow('error');
    });
  });

  describe('getTokenClaims', () => {
    beforeEach(async () => {
      const nextCookies = await cookies();
      // @ts-expect-error - _reset is part of the mock
      nextCookies._reset();
      jest.clearAllMocks();
    });

    it('should return all token claims when accessToken is provided', async () => {
      const tokenPayload = {
        sub: 'user_123',
        org_id: 'org_123',
        role: 'admin',
        permissions: ['read', 'write'],
        entitlements: ['feature_a'],
        feature_flags: ['device-authorization-grant'],
        department: 'engineering',
        level: 5,
        metadata: { theme: 'dark' },
      };
      const token = await generateTestToken(tokenPayload);

      const result = await getTokenClaims(token);

      expect(result).toMatchObject(tokenPayload);
    });

    it('should return empty object when no accessToken is provided and no session exists', async () => {
      const result = await getTokenClaims();

      expect(result).toEqual({});
    });

    it('should return all standard claims when token has only standard claims', async () => {
      const tokenPayload = {
        sub: 'user_123',
        org_id: 'org_123',
        role: 'admin',
        permissions: ['read', 'write'],
        entitlements: ['feature_a'],
        feature_flags: ['device-authorization-grant'],
      };
      const token = await generateTestToken(tokenPayload);

      const result = await getTokenClaims(token);

      expect(result).toMatchObject(tokenPayload);
    });

    it('should return all claims including standard JWT claims', async () => {
      const customClaims = {
        customField: 'value',
        anotherCustom: 42,
      };
      const standardClaims = {
        aud: 'audience',
        sub: 'user_123',
        sid: 'session_123',
        org_id: 'org_123',
        role: 'admin',
        permissions: ['read', 'write'],
        entitlements: ['feature_a'],
        feature_flags: ['device-authorization-grant'],
        jti: 'jwt_123',
      };
      const token = await generateTestToken({ ...standardClaims, ...customClaims });

      const result = await getTokenClaims(token);

      expect(result).toMatchObject({ ...standardClaims, ...customClaims });
      expect(result).toHaveProperty('exp');
      expect(result).toHaveProperty('iat');
      expect(result).toHaveProperty('iss');
    });

    it('should handle complex nested claims', async () => {
      const tokenPayload = {
        sub: 'user_123',
        org_id: 'org_123',
        metadata: {
          preferences: { theme: 'dark', language: 'en' },
          settings: ['setting1', 'setting2'],
        },
        tags: ['tag1', 'tag2'],
        permissions_custom: { read: true, write: false },
      };
      const token = await generateTestToken(tokenPayload);

      const result = await getTokenClaims(token);

      expect(result).toMatchObject(tokenPayload);
    });
  });
});



================================================
FILE: __tests__/test-helpers.ts
================================================
// istanbul ignore file

import { sealData } from 'iron-session';
import { SignJWT } from 'jose';
import { WORKOS_COOKIE_NAME, WORKOS_COOKIE_PASSWORD } from '../src/env-variables.js';
import { cookies } from 'next/headers';
import { User } from '@workos-inc/node';

export async function generateTestToken(payload = {}, expired = false) {
  const defaultPayload = {
    sid: 'session_123',
    org_id: 'org_123',
    role: 'member',
    permissions: ['posts:create', 'posts:delete'],
    entitlements: ['audit-logs'],
    feature_flags: ['device-authorization-grant'],
  };

  const mergedPayload = { ...defaultPayload, ...payload };

  const secret = new TextEncoder().encode(process.env.WORKOS_COOKIE_PASSWORD as string);

  const token = await new SignJWT(mergedPayload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setIssuer('urn:example:issuer')
    .setExpirationTime(expired ? '0s' : '2h')
    .sign(secret);

  return token;
}

export async function generateSession(overrides: Partial<User> = {}) {
  const mockUser = {
    id: 'user_123',
    email: 'test@example.com',
    emailVerified: true,
    profilePictureUrl: null,
    firstName: 'Test',
    lastName: 'User',
    object: 'user',
    createdAt: '2024-01-01T00:00:00Z',
    updatedAt: '2024-01-01T00:00:00Z',
    lastSignInAt: '2024-01-01T00:00:00Z',
    externalId: null,
    metadata: {},
    ...overrides,
  } satisfies User;

  const accessToken = await generateTestToken({
    sid: 'session_123',
    org_id: 'org_123',
  });

  // Create and set a session cookie
  const encryptedSession = await sealData(
    {
      accessToken,
      refreshToken: 'refresh_token_123',
      user: mockUser,
    },
    {
      password: WORKOS_COOKIE_PASSWORD as string,
    },
  );

  const cookieName = WORKOS_COOKIE_NAME || 'wos-session';
  const nextCookies = await cookies();
  nextCookies.set(cookieName, encryptedSession);
}



================================================
FILE: __tests__/useAccessToken.spec.tsx
================================================
import '@testing-library/jest-dom';
import { act, render, waitFor } from '@testing-library/react';
import React from 'react';
import { getAccessTokenAction, refreshAccessTokenAction } from '../src/actions.js';
import { useAuth } from '../src/components/authkit-provider.js';
import { useAccessToken } from '../src/components/useAccessToken.js';

jest.mock('../src/actions.js', () => ({
  getAccessTokenAction: jest.fn(),
  refreshAccessTokenAction: jest.fn(),
}));

jest.mock('../src/components/authkit-provider.js', () => {
  const originalModule = jest.requireActual('../src/components/authkit-provider.js');
  return {
    ...originalModule,
    useAuth: jest.fn(),
  };
});

describe('useAccessToken', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();

    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user_123' },
      sessionId: 'session_123',
      refreshAuth: jest.fn().mockResolvedValue({}),
    }));
  });

  afterEach(() => {
    jest.clearAllTimers();
    jest.useRealTimers();
  });

  const TestComponent = () => {
    const { accessToken, loading, error, refresh } = useAccessToken();
    return (
      <div>
        <div data-testid="token">{accessToken || 'no-token'}</div>
        <div data-testid="loading">{loading.toString()}</div>
        <div data-testid="error">{error?.message || 'no-error'}</div>
        <button data-testid="refresh" onClick={() => refresh()}>
          Refresh
        </button>
      </div>
    );
  };

  it('should fetch an access token on mount', async () => {
    const mockToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';
    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(mockToken);

    const { getByTestId } = render(<TestComponent />);

    expect(getByTestId('loading')).toHaveTextContent('true');

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('token')).toHaveTextContent(mockToken);
    });

    expect(getAccessTokenAction).toHaveBeenCalledTimes(1);
  });

  it('should handle token refresh when an expiring token is received', async () => {
    // Create a token that's about to expire (exp is very close to current time)
    const currentTimeInSeconds = Math.floor(Date.now() / 1000);
    const payload = { sub: '1234567890', sid: 'session_123', exp: currentTimeInSeconds + 30 };
    const expiringToken = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${btoa(JSON.stringify(payload))}.mock-signature`;

    const refreshedToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';

    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(expiringToken);
    (refreshAccessTokenAction as jest.Mock).mockResolvedValueOnce(refreshedToken);

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('token')).toHaveTextContent(refreshedToken);
    });

    expect(getAccessTokenAction).toHaveBeenCalledTimes(1);
    expect(refreshAccessTokenAction).toHaveBeenCalledTimes(1);
  });

  it('should handle token refresh on manual refresh', async () => {
    const initialToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';
    const refreshedToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJyZWZyZXNoZWQiLCJzaWQiOiJzZXNzaW9uXzEyMyIsImV4cCI6OTk5OTk5OTk5OX0.mock-signature-2';

    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(initialToken).mockResolvedValueOnce(refreshedToken);

    const mockRefreshAuth = jest.fn().mockResolvedValue({});
    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user_123' },
      sessionId: 'session_123',
      refreshAuth: mockRefreshAuth,
    }));

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('token')).toHaveTextContent(initialToken);
    });

    act(() => {
      getByTestId('refresh').click();
    });

    await waitFor(() => {
      expect(mockRefreshAuth).toHaveBeenCalledTimes(1);
      expect(getAccessTokenAction).toHaveBeenCalledTimes(2);
      expect(getByTestId('token')).toHaveTextContent(refreshedToken);
    });
  });

  it('should schedule automatic token refresh before expiration', async () => {
    // Create a token that expires in 2 minutes
    const currentTimeInSeconds = Math.floor(Date.now() / 1000);
    const expTimeInSeconds = currentTimeInSeconds + 120; // 2 minutes in future
    const payload = { sub: '1234567890', sid: 'session_123', exp: expTimeInSeconds };
    const token = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${btoa(JSON.stringify(payload))}.mock-signature`;

    const refreshedToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJyZWZyZXNoZWQiLCJzaWQiOiJzZXNzaW9uXzEyMyIsImV4cCI6OTk5OTk5OTk5OX0.mock-signature-2';

    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(token);
    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(refreshedToken);

    render(<TestComponent />);

    await waitFor(() => {
      expect(getAccessTokenAction).toHaveBeenCalledTimes(1);
    });

    act(() => {
      jest.advanceTimersByTime((120 - 60) * 1000);
    });

    await waitFor(() => {
      expect(getAccessTokenAction).toHaveBeenCalledTimes(2);
    });
  });

  it('should handle the not loggged in state', async () => {
    (useAuth as jest.Mock).mockImplementation(() => ({
      user: undefined,
      sessionId: undefined,
      refreshAuth: jest.fn().mockResolvedValue({}),
    }));

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('token')).toHaveTextContent('no-token');
    });
  });

  it('should handle errors during token fetch', async () => {
    const error = new Error('Failed to fetch token');
    (getAccessTokenAction as jest.Mock).mockRejectedValueOnce(error);

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('error')).toHaveTextContent('Failed to fetch token');
      expect(getByTestId('token')).toHaveTextContent('no-token');
    });
  });

  it('should handle errors during manual refresh', async () => {
    const initialToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';
    const error = new Error('Failed to refresh token');

    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(initialToken);

    const mockRefreshAuth = jest.fn().mockRejectedValueOnce(error);
    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user_123' },
      sessionId: 'session_123',
      refreshAuth: mockRefreshAuth,
    }));

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('token')).toHaveTextContent(initialToken);
    });

    await act(async () => {
      getByTestId('refresh').click();
    });

    await waitFor(() => {
      expect(mockRefreshAuth).toHaveBeenCalledTimes(1);
      expect(getByTestId('error')).toHaveTextContent('Failed to refresh token');
    });
  });

  it('should reset token state when user is undefined', async () => {
    const mockToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';
    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(mockToken);

    // First render with user
    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user_123' },
      sessionId: 'session_123',
      refreshAuth: jest.fn().mockResolvedValue({}),
    }));

    const { getByTestId, rerender } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('token')).toHaveTextContent(mockToken);
    });

    (useAuth as jest.Mock).mockImplementation(() => ({
      user: undefined,
      sessionId: undefined,
      refreshAuth: jest.fn().mockResolvedValue({}),
    }));

    rerender(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('token')).toHaveTextContent('no-token');
    });
  });

  it('should handle invalid tokens gracefully', async () => {
    const invalidToken = 'invalid-token';
    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(invalidToken);

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('token')).toHaveTextContent('no-token');
    });
  });

  it('should retry fetching when an error occurs', async () => {
    const error = new Error('Failed to fetch token');
    const mockToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';

    (getAccessTokenAction as jest.Mock).mockRejectedValueOnce(error).mockResolvedValueOnce(mockToken);

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('error')).toHaveTextContent('Failed to fetch token');
    });

    act(() => {
      jest.advanceTimersByTime(5 * 60 * 1000); // RETRY_DELAY
    });

    await waitFor(() => {
      expect(getAccessTokenAction).toHaveBeenCalledTimes(2);
      expect(getByTestId('token')).toHaveTextContent(mockToken);
      expect(getByTestId('error')).toHaveTextContent('no-error');
    });
  });

  it('should handle errors when refreshing an expiring token', async () => {
    // Create a token that's about to expire
    const currentTimeInSeconds = Math.floor(Date.now() / 1000);
    const payload = { sub: '1234567890', sid: 'session_123', exp: currentTimeInSeconds + 30 };
    const expiringToken = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${btoa(JSON.stringify(payload))}.mock-signature`;
    const error = new Error('Failed to refresh token');

    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(expiringToken);
    (refreshAccessTokenAction as jest.Mock).mockRejectedValueOnce(error);

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('error')).toHaveTextContent('Failed to refresh token');
    });

    expect(getAccessTokenAction).toHaveBeenCalledTimes(1);
    expect(refreshAccessTokenAction).toHaveBeenCalledTimes(1);
  });

  it('should handle token with an invalid payload format', async () => {
    const badPayloadToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalidpayload.mock-signature';
    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(badPayloadToken);

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('token')).toHaveTextContent('no-token');
    });
  });

  it('should immediately try to update token when token is undefined', async () => {
    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(undefined).mockResolvedValueOnce(undefined);

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('token')).toHaveTextContent('no-token');
    });

    expect(getAccessTokenAction).toHaveBeenCalledTimes(1);
  });

  it('should react to sessionId changes', async () => {
    // Clear any previous mocks to ensure clean state
    jest.clearAllMocks();

    const token1 = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMSIsImV4cCI6OTk5OTk5OTk5OX0.mock-signature-1';
    const token2 = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMSIsImV4cCI6OTk5OTk5OTk5OX0.mock-signature-2';

    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(token1).mockResolvedValueOnce(token2);

    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user1' },
      sessionId: 'session1',
      refreshAuth: jest.fn().mockResolvedValue({}),
    }));

    const { rerender } = render(<TestComponent />);

    await waitFor(() => {
      expect(getAccessTokenAction).toHaveBeenCalledTimes(1);
    });

    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user1' }, // Same user ID
      sessionId: 'session2',
      refreshAuth: jest.fn().mockResolvedValue({}),
    }));

    rerender(<TestComponent />);

    await waitFor(() => {
      expect(getAccessTokenAction).toHaveBeenCalledTimes(2);
    });
  });

  it('should prevent concurrent token fetches via updateToken', async () => {
    jest.clearAllMocks();
    (getAccessTokenAction as jest.Mock).mockReset();

    const mockToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';

    let fetchCalls = 0;

    const tokenPromise = new Promise<string>((resolve) => {
      setTimeout(() => {
        resolve(mockToken);
      }, 0);
    });

    (getAccessTokenAction as jest.Mock).mockImplementation(() => {
      fetchCalls++;
      return tokenPromise;
    });

    const { getByTestId } = render(<TestComponent />);

    expect(getByTestId('loading')).toHaveTextContent('true');

    await waitFor(() => {
      expect(fetchCalls).toBe(1);
    });

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('token')).toHaveTextContent(mockToken);
    });

    expect(fetchCalls).toBe(1);
  });

  it('should prevent concurrent manual refresh operations', async () => {
    jest.clearAllMocks();

    let refreshAuthCalls = 0;

    const mockToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const refreshAuthPromise = new Promise<any>((resolve) => {
      // Slow promise
      setTimeout(() => resolve({}), 10);
    });

    const mockRefreshAuth = jest.fn().mockImplementation(() => {
      refreshAuthCalls++;
      return refreshAuthPromise;
    });

    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user_123' },
      sessionId: 'session_123',
      refreshAuth: mockRefreshAuth,
    }));

    (getAccessTokenAction as jest.Mock).mockImplementation(() => {
      return Promise.resolve(mockToken);
    });

    const { getByTestId } = render(<TestComponent />);

    // Wait for initial token
    await waitFor(() => {
      expect(getByTestId('token')).toHaveTextContent(mockToken);
    });

    // Call refresh twice in succession - should only result in one actual refresh call
    act(() => {
      getByTestId('refresh').click();
      getByTestId('refresh').click();
    });

    // Wait for refresh to complete
    await waitFor(() => {
      expect(refreshAuthCalls).toBe(1);
    });

    // Verify that refreshAuth was only called once despite two clicks
    expect(refreshAuthCalls).toBe(1);
  });

  it('should handle non-Error objects thrown during token fetch', async () => {
    // Simulate a string error being thrown
    (getAccessTokenAction as jest.Mock).mockImplementation(() => {
      throw 'String error message';
    });

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('error')).toHaveTextContent('String error message');
    });
  });

  // Additional test cases to increase coverage
  it('should handle concurrent manual refresh attempts', async () => {
    const initialToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';
    const refreshedToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJyZWZyZXNoZWQiLCJzaWQiOiJzZXNzaW9uXzEyMyIsImV4cCI6OTk5OTk5OTk5OX0.mock-signature-2';

    // Setup a delayed promise for the refresh auth
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let resolveRefreshPromise: (value: any) => void;
    const refreshPromise = new Promise((resolve) => {
      resolveRefreshPromise = resolve;
    });

    const mockRefreshAuth = jest.fn().mockReturnValue(refreshPromise);
    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user_123' },
      sessionId: 'session_123',
      refreshAuth: mockRefreshAuth,
    }));

    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(initialToken).mockResolvedValueOnce(refreshedToken);

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('token')).toHaveTextContent(initialToken);
    });

    act(() => {
      getByTestId('refresh').click();
    });

    act(() => {
      getByTestId('refresh').click();
    });

    act(() => {
      resolveRefreshPromise!({});
    });

    await waitFor(() => {
      expect(mockRefreshAuth).toHaveBeenCalledTimes(1); // Should only call once
      expect(getAccessTokenAction).toHaveBeenCalledTimes(2);
      expect(getByTestId('token')).toHaveTextContent(refreshedToken);
    });
  });

  it('should handle errors during token refresh when autoRefresh is scheduled', async () => {
    // Create a token that expires in 2 minutes
    const currentTimeInSeconds = Math.floor(Date.now() / 1000);
    const expTimeInSeconds = currentTimeInSeconds + 120; // 2 minutes in future
    const payload = { sub: '1234567890', sid: 'session_123', exp: expTimeInSeconds };
    const token = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${btoa(JSON.stringify(payload))}.mock-signature`;

    const error = new Error('Failed to refresh token');

    (getAccessTokenAction as jest.Mock)
      .mockResolvedValueOnce(token) // Initial fetch succeeds
      .mockRejectedValueOnce(error); // But auto-refresh fails

    render(<TestComponent />);

    await waitFor(() => {
      expect(getAccessTokenAction).toHaveBeenCalledTimes(1);
    });

    act(() => {
      jest.advanceTimersByTime((120 - 60) * 1000);
    });

    await waitFor(() => {
      expect(getAccessTokenAction).toHaveBeenCalledTimes(2);
    });
  });

  it('should clear refresh timeout on unmount', async () => {
    const mockToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';
    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(mockToken);

    const { getByTestId, unmount } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('token')).toHaveTextContent(mockToken);
    });

    unmount();
  });

  it('should handle edge cases when token data is null', async () => {
    // Create a token that resembles a JWT but with a null payload
    const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.bnVsbA==.mock-signature'; // "null" in base64
    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(token);

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
    });

    expect(getByTestId('token')).toHaveTextContent('no-token');
  });

  it('should handle errors with string messages instead of Error objects', async () => {
    const error = 'String error message';
    const errorObj = new Error(error);
    (getAccessTokenAction as jest.Mock).mockRejectedValueOnce(errorObj);

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('loading')).toHaveTextContent('false');
      expect(getByTestId('error')).toHaveTextContent(error);
    });
  });

  it('should handle string errors during manual refresh', async () => {
    const initialToken =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';
    const stringError = 'String error directly'; // Not wrapped in Error object

    (getAccessTokenAction as jest.Mock).mockResolvedValueOnce(initialToken);

    // Mock refreshAuth to reject with a string, not an Error object
    const mockRefreshAuth = jest.fn().mockImplementation(() => {
      return Promise.reject(stringError); // Directly reject with string
    });

    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user_123' },
      sessionId: 'session_123',
      refreshAuth: mockRefreshAuth,
    }));

    const { getByTestId } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('token')).toHaveTextContent(initialToken);
    });

    act(() => {
      getByTestId('refresh').click();
    });

    await waitFor(() => {
      expect(mockRefreshAuth).toHaveBeenCalledTimes(1);
      expect(getByTestId('error')).toHaveTextContent(stringError);
    });
  });

  it('should bypass refresh when token is unchanged but user or sessionId changed', async () => {
    const token =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2lkIjoic2Vzc2lvbl8xMjMiLCJleHAiOjk5OTk5OTk5OTl9.mock-signature';

    (getAccessTokenAction as jest.Mock).mockResolvedValue(token);

    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user_123' },
      sessionId: 'session_123',
      refreshAuth: jest.fn().mockResolvedValue({}),
    }));

    const { getByTestId, rerender } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByTestId('token')).toHaveTextContent(token);
      expect(getAccessTokenAction).toHaveBeenCalledTimes(1);
    });

    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user_456' }, // Different user
      sessionId: 'session_123', // Same session
      refreshAuth: jest.fn().mockResolvedValue({}),
    }));

    rerender(<TestComponent />);

    await waitFor(() => {
      expect(getAccessTokenAction).toHaveBeenCalledTimes(2);
    });
  });
});



================================================
FILE: __tests__/useTokenClaims.spec.tsx
================================================
import '@testing-library/jest-dom';
import { render, waitFor } from '@testing-library/react';
import React from 'react';
import { useAuth } from '../src/components/authkit-provider.js';

jest.mock('../src/actions.js', () => ({
  getAccessTokenAction: jest.fn(),
  refreshAccessTokenAction: jest.fn(),
}));

jest.mock('../src/components/authkit-provider.js', () => {
  const originalModule = jest.requireActual('../src/components/authkit-provider.js');
  return {
    ...originalModule,
    useAuth: jest.fn(),
  };
});

jest.mock('../src/components/useAccessToken.js', () => ({
  useAccessToken: jest.fn(() => ({ accessToken: undefined })),
}));

jest.mock('jose', () => ({
  decodeJwt: jest.fn((token: string) => {
    if (token === 'malformed-token' || token === 'throw-error-token') {
      throw new Error('Invalid JWT');
    }
    try {
      const parts = token.split('.');
      if (parts.length !== 3) throw new Error('Invalid JWT');
      const payload = JSON.parse(atob(parts[1]));
      return payload;
    } catch {
      throw new Error('Invalid JWT');
    }
  }),
}));

// Import after mocks are set up
import { useAccessToken } from '../src/components/useAccessToken.js';
import { useTokenClaims } from '../src/components/useTokenClaims.js';

describe('useTokenClaims', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();

    (useAuth as jest.Mock).mockImplementation(() => ({
      user: { id: 'user_123' },
      sessionId: 'session_123',
      refreshAuth: jest.fn().mockResolvedValue({}),
    }));

    // Reset useAccessToken mock to default
    (useAccessToken as jest.Mock).mockReturnValue({ accessToken: undefined });
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  const TokenClaimsTestComponent = () => {
    const tokenClaims = useTokenClaims();
    return (
      <div>
        <div data-testid="claims">{JSON.stringify(tokenClaims)}</div>
      </div>
    );
  };

  it('should return empty object when no access token is available', async () => {
    (useAccessToken as jest.Mock).mockReturnValue({ accessToken: undefined });

    const { getByTestId } = render(<TokenClaimsTestComponent />);

    await waitFor(() => {
      expect(getByTestId('claims')).toHaveTextContent('{}');
    });
  });

  it('should return all token claims when access token is available', async () => {
    const payload = {
      aud: 'audience',
      exp: 9999999999,
      iat: 1234567800,
      iss: 'issuer',
      sub: 'user_123',
      sid: 'session_123',
      org_id: 'org_123',
      role: 'admin',
      permissions: ['read', 'write'],
      entitlements: ['feature_a'],
      feature_flags: ['device-authorization-grant'],
      jti: 'jwt_123',
      nbf: 1234567800,
      // Custom claims
      customField1: 'value1',
      customField2: 42,
      customObject: { nested: 'data' },
    };
    const token = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${btoa(JSON.stringify(payload))}.mock-signature`;

    (useAccessToken as jest.Mock).mockReturnValue({ accessToken: token });

    const { getByTestId } = render(<TokenClaimsTestComponent />);

    await waitFor(() => {
      expect(getByTestId('claims')).toHaveTextContent(JSON.stringify(payload));
    });
  });

  it('should return all standard claims when token has only standard claims', async () => {
    const payload = {
      aud: 'audience',
      exp: 9999999999,
      iat: 1234567800,
      iss: 'issuer',
      sub: 'user_123',
      sid: 'session_123',
      org_id: 'org_123',
      role: 'admin',
      permissions: ['read', 'write'],
      entitlements: ['feature_a'],
      feature_flags: ['device-authorization-grant'],
      jti: 'jwt_123',
      nbf: 1234567800,
    };
    const token = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${btoa(JSON.stringify(payload))}.mock-signature`;

    (useAccessToken as jest.Mock).mockReturnValue({ accessToken: token });

    const { getByTestId } = render(<TokenClaimsTestComponent />);

    await waitFor(() => {
      expect(getByTestId('claims')).toHaveTextContent(JSON.stringify(payload));
    });
  });

  it('should handle partial claims', async () => {
    const payload = {
      sub: 'user_123',
      exp: 9999999999,
      customField: 'value',
      anotherCustom: true,
    };
    const token = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${btoa(JSON.stringify(payload))}.mock-signature`;

    (useAccessToken as jest.Mock).mockReturnValue({ accessToken: token });

    const { getByTestId } = render(<TokenClaimsTestComponent />);

    await waitFor(() => {
      expect(getByTestId('claims')).toHaveTextContent(JSON.stringify(payload));
    });
  });

  it('should handle complex nested claims', async () => {
    const payload = {
      sub: 'user_123',
      exp: 9999999999,
      metadata: {
        preferences: {
          theme: 'dark',
          language: 'en',
        },
        settings: ['setting1', 'setting2'],
      },
      tags: ['tag1', 'tag2'],
      permissions_custom: {
        read: true,
        write: false,
      },
    };
    const token = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${btoa(JSON.stringify(payload))}.mock-signature`;

    (useAccessToken as jest.Mock).mockReturnValue({ accessToken: token });

    const { getByTestId } = render(<TokenClaimsTestComponent />);

    await waitFor(() => {
      expect(getByTestId('claims')).toHaveTextContent(JSON.stringify(payload));
    });
  });

  it('should return empty object when decodeJwt throws an error', async () => {
    (useAccessToken as jest.Mock).mockReturnValue({ accessToken: 'malformed-token' });

    const { getByTestId } = render(<TokenClaimsTestComponent />);

    await waitFor(() => {
      expect(getByTestId('claims')).toHaveTextContent('{}');
    });
  });
});



================================================
FILE: __tests__/utils.spec.ts
================================================
import { NextResponse } from 'next/server';
import { redirectWithFallback, errorResponseWithFallback } from '../src/utils.js';

describe('utils', () => {
  afterEach(() => {
    jest.resetModules();
  });

  describe('redirectWithFallback', () => {
    it('uses NextResponse.redirect when available', () => {
      const redirectUrl = 'https://example.com';
      const mockRedirect = jest.fn().mockReturnValue('redirected');
      const originalRedirect = NextResponse.redirect;

      NextResponse.redirect = mockRedirect;

      const result = redirectWithFallback(redirectUrl);

      expect(mockRedirect).toHaveBeenCalledWith(redirectUrl, { headers: undefined });
      expect(result).toBe('redirected');

      NextResponse.redirect = originalRedirect;
    });

    it('uses headers when provided', () => {
      const redirectUrl = 'https://example.com';
      const headers = new Headers();
      headers.set('Set-Cookie', 'test=1');

      const result = redirectWithFallback(redirectUrl, headers);

      expect(result.headers.get('Set-Cookie')).toBe('test=1');
    });

    it('falls back to standard Response when NextResponse exists but redirect is undefined', async () => {
      const redirectUrl = 'https://example.com';

      jest.resetModules();

      jest.mock('next/server', () => ({
        NextResponse: {
          // exists but has no redirect method
        },
      }));

      const { redirectWithFallback } = await import('../src/utils.js');

      const result = redirectWithFallback(redirectUrl);

      expect(result).toBeInstanceOf(Response);
      expect(result.status).toBe(307);
      expect(result.headers.get('Location')).toBe(redirectUrl);
    });

    it('falls back to standard Response when NextResponse is undefined', async () => {
      const redirectUrl = 'https://example.com';

      jest.resetModules();

      // Mock with undefined NextResponse
      jest.mock('next/server', () => ({
        NextResponse: undefined,
      }));

      const { redirectWithFallback } = await import('../src/utils.js');

      const result = redirectWithFallback(redirectUrl);

      expect(result).toBeInstanceOf(Response);
      expect(result.status).toBe(307);
      expect(result.headers.get('Location')).toBe(redirectUrl);
    });
  });

  describe('errorResponseWithFallback', () => {
    const errorBody = {
      error: {
        message: 'Test error',
        description: 'Test description',
      },
    };

    it('uses NextResponse.json when available', () => {
      const mockJson = jest.fn().mockReturnValue('error json response');
      NextResponse.json = mockJson;

      const result = errorResponseWithFallback(errorBody);

      expect(mockJson).toHaveBeenCalledWith(errorBody, { status: 500 });
      expect(result).toBe('error json response');
    });

    it('falls back to standard Response when NextResponse is not available', () => {
      const originalJson = NextResponse.json;

      // @ts-expect-error - This is to test the fallback
      delete NextResponse.json;

      const result = errorResponseWithFallback(errorBody);

      expect(result).toBeInstanceOf(Response);
      expect(result.status).toBe(500);
      expect(result.headers.get('Content-Type')).toBe('application/json');

      NextResponse.json = originalJson;
    });

    it('falls back to standard Response when NextResponse exists but json is undefined', async () => {
      jest.resetModules();

      jest.mock('next/server', () => ({
        NextResponse: {
          // exists but has no json method
        },
      }));

      const { errorResponseWithFallback } = await import('../src/utils.js');

      const result = errorResponseWithFallback(errorBody);

      expect(result).toBeInstanceOf(Response);
      expect(result.status).toBe(500);
      expect(result.headers.get('Content-Type')).toBe('application/json');
    });

    it('falls back to standard Response when NextResponse is undefined', async () => {
      jest.resetModules();

      jest.mock('next/server', () => ({
        NextResponse: undefined,
      }));

      const { errorResponseWithFallback } = await import('../src/utils.js');

      const result = errorResponseWithFallback(errorBody);

      expect(result).toBeInstanceOf(Response);
      expect(result.status).toBe(500);
      expect(result.headers.get('Content-Type')).toBe('application/json');
    });
  });
});



================================================
FILE: __tests__/workos.spec.ts
================================================
import { WorkOS } from '@workos-inc/node';
import { getWorkOS, VERSION } from '../src/workos.js';

describe('workos', () => {
  const workos = getWorkOS();
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('initializes WorkOS with the correct configuration', () => {
    // Extracting the config to avoid a circular dependency error
    const workosConfig = {
      apiHostname: workos.options.apiHostname,
      https: workos.options.https,
      port: workos.options.port,
      appInfo: workos.options.appInfo,
    };

    expect(workosConfig).toEqual({
      apiHostname: undefined,
      https: true,
      port: undefined,
      appInfo: {
        name: 'authkit/nextjs',
        version: VERSION,
      },
    });
  });

  it('exports a WorkOS instance', () => {
    expect(workos).toBeInstanceOf(WorkOS);
  });

  describe('with custom environment variables', () => {
    const originalEnv = process.env;

    beforeEach(() => {
      jest.resetModules();
      process.env = { ...originalEnv };
    });

    afterEach(() => {
      process.env = originalEnv;
    });

    it('uses custom API hostname when provided', async () => {
      process.env.WORKOS_API_HOSTNAME = 'custom.workos.com';
      const { getWorkOS: customWorkos } = await import('../src/workos.js');

      expect(customWorkos().options.apiHostname).toEqual('custom.workos.com');
    });

    it('uses custom HTTPS setting when provided', async () => {
      process.env.WORKOS_API_HTTPS = 'false';
      const { getWorkOS: customWorkos } = await import('../src/workos.js');

      expect(customWorkos().options.https).toEqual(false);
    });

    it('uses custom port when provided', async () => {
      process.env.WORKOS_API_PORT = '8080';
      const { getWorkOS: customWorkos } = await import('../src/workos.js');

      expect(customWorkos().options.port).toEqual(8080);
    });
  });
});



================================================
FILE: src/actions.ts
================================================
'use server';

import { signOut, switchToOrganization } from './auth.js';
import { NoUserInfo, UserInfo, SwitchToOrganizationOptions } from './interfaces.js';
import { refreshSession, withAuth } from './session.js';
import { getWorkOS } from './workos.js';

/**
 * This function is used to sanitize the auth object.
 * Remove the accessToken from the auth object as it is not needed on the client side.
 * @param value - The auth object to sanitize
 * @returns The sanitized auth object
 */
function sanitize<T extends UserInfo | NoUserInfo>(value: T) {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { accessToken, ...sanitized } = value;
  return sanitized;
}

/**
 * This action is only accessible to authenticated users,
 * there is no need to check the session here as the middleware will
 * be responsible for that.
 */
export const checkSessionAction = async () => {
  return true;
};

export const handleSignOutAction = async ({ returnTo }: { returnTo?: string } = {}) => {
  await signOut({ returnTo });
};

export const getOrganizationAction = async (organizationId: string) => {
  return await getWorkOS().organizations.getOrganization(organizationId);
};

export const getAuthAction = async (options?: { ensureSignedIn?: boolean }) => {
  return sanitize(await withAuth(options));
};

export const refreshAuthAction = async ({
  ensureSignedIn,
  organizationId,
}: {
  ensureSignedIn?: boolean;
  organizationId?: string;
}) => {
  return sanitize(await refreshSession({ ensureSignedIn, organizationId }));
};

export const switchToOrganizationAction = async (organizationId: string, options?: SwitchToOrganizationOptions) => {
  return sanitize(await switchToOrganization(organizationId, options));
};

/**
 * This action is used to get the access token from the auth object.
 * It is used to fetch the access token from the server.
 */
export async function getAccessTokenAction() {
  const auth = await withAuth();
  return auth.accessToken;
}

/**
 * This action is used to refresh the access token from the auth object.
 * It is used to fetch the access token from the server.
 */
export async function refreshAccessTokenAction() {
  const auth = await refreshSession();
  return auth.accessToken;
}



================================================
FILE: src/auth.ts
================================================
'use server';

import { revalidatePath, revalidateTag } from 'next/cache';
import { cookies, headers } from 'next/headers';
import { redirect } from 'next/navigation';
import { WORKOS_COOKIE_DOMAIN, WORKOS_COOKIE_NAME } from './env-variables.js';
import { getAuthorizationUrl } from './get-authorization-url.js';
import { SwitchToOrganizationOptions, UserInfo } from './interfaces.js';
import { refreshSession, withAuth } from './session.js';
import { getWorkOS } from './workos.js';
export async function getSignInUrl({
  organizationId,
  loginHint,
  redirectUri,
}: { organizationId?: string; loginHint?: string; redirectUri?: string } = {}) {
  return getAuthorizationUrl({ organizationId, screenHint: 'sign-in', loginHint, redirectUri });
}

export async function getSignUpUrl({
  organizationId,
  loginHint,
  redirectUri,
}: { organizationId?: string; loginHint?: string; redirectUri?: string } = {}) {
  return getAuthorizationUrl({ organizationId, screenHint: 'sign-up', loginHint, redirectUri });
}

/**
 * Sign out the user and delete the session cookie.
 * @param options Options for signing out.
 * @param options.returnTo The URL to redirect to after signing out.
 */
export async function signOut({ returnTo }: { returnTo?: string } = {}) {
  let sessionId: string | undefined;

  try {
    const { sessionId: sid } = await withAuth();
    sessionId = sid;
  } finally {
    const nextCookies = await cookies();
    const cookieName = WORKOS_COOKIE_NAME || 'wos-session';
    const domain = WORKOS_COOKIE_DOMAIN || /* istanbul ignore next */ undefined;
    nextCookies.delete({ name: cookieName, domain, path: '/' });

    if (sessionId) {
      redirect(getWorkOS().userManagement.getLogoutUrl({ sessionId, returnTo }));
    } else {
      redirect(returnTo ?? '/');
    }
  }
}

export async function switchToOrganization(
  organizationId: string,
  options: SwitchToOrganizationOptions = {},
): Promise<UserInfo> {
  const { returnTo, revalidationStrategy = 'path', revalidationTags = [] } = options;
  const headersList = await headers();
  let result: UserInfo;
  // istanbul ignore next
  const pathname = returnTo || headersList.get('x-url') || '/';
  try {
    result = await refreshSession({ organizationId, ensureSignedIn: true });
  } catch (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    error: any
  ) {
    const { cause } = error;
    /* istanbul ignore next */
    if (cause?.rawData?.authkit_redirect_url) {
      redirect(cause.rawData.authkit_redirect_url);
    } else {
      if (cause?.error === 'sso_required' || cause?.error === 'mfa_enrollment') {
        const url = await getAuthorizationUrl({ organizationId });
        return redirect(url);
      }
      throw error;
    }
  }

  switch (revalidationStrategy) {
    case 'path':
      revalidatePath(pathname);
      break;
    case 'tag':
      for (const tag of revalidationTags) {
        revalidateTag(tag);
      }
      break;
  }
  if (revalidationStrategy !== 'none') {
    redirect(pathname);
  }

  return result;
}



================================================
FILE: src/authkit-callback-route.ts
================================================
import { NextRequest } from 'next/server';
import { WORKOS_CLIENT_ID } from './env-variables.js';
import { HandleAuthOptions } from './interfaces.js';
import { saveSession } from './session.js';
import { errorResponseWithFallback, redirectWithFallback } from './utils.js';
import { getWorkOS } from './workos.js';

export function handleAuth(options: HandleAuthOptions = {}) {
  const { returnPathname: returnPathnameOption = '/', baseURL, onSuccess, onError } = options;

  // Throw early if baseURL is provided but invalid
  if (baseURL) {
    try {
      new URL(baseURL);
    } catch (error) {
      throw new Error(`Invalid baseURL: ${baseURL}`, { cause: error });
    }
  }

  return async function GET(request: NextRequest) {
    const code = request.nextUrl.searchParams.get('code');
    const state = request.nextUrl.searchParams.get('state');
    let returnPathname = state && state !== 'null' ? JSON.parse(atob(state)).returnPathname : null;

    if (code) {
      try {
        // Use the code returned to us by AuthKit and authenticate the user with WorkOS
        const { accessToken, refreshToken, user, impersonator, oauthTokens, authenticationMethod, organizationId } =
          await getWorkOS().userManagement.authenticateWithCode({
            clientId: WORKOS_CLIENT_ID,
            code,
          });

        // If baseURL is provided, use it instead of request.nextUrl
        // This is useful if the app is being run in a container like docker where
        // the hostname can be different from the one in the request
        const url = baseURL ? new URL(baseURL) : request.nextUrl.clone();

        // Cleanup params
        url.searchParams.delete('code');
        url.searchParams.delete('state');

        // Redirect to the requested path and store the session
        returnPathname = returnPathname ?? returnPathnameOption;

        // Extract the search params if they are present
        if (returnPathname.includes('?')) {
          const newUrl = new URL(returnPathname, 'https://example.com');
          url.pathname = newUrl.pathname;

          for (const [key, value] of newUrl.searchParams) {
            url.searchParams.append(key, value);
          }
        } else {
          url.pathname = returnPathname;
        }

        // Fall back to standard Response if NextResponse is not available.
        // This is to support Next.js 13.
        const response = redirectWithFallback(url.toString());

        if (!accessToken || !refreshToken) throw new Error('response is missing tokens');

        if (onSuccess) {
          await onSuccess({
            accessToken,
            refreshToken,
            user,
            impersonator,
            oauthTokens,
            authenticationMethod,
            organizationId,
          });
        }

        await saveSession({ accessToken, refreshToken, user, impersonator }, request);

        return response;
      } catch (error) {
        const errorRes = {
          error: error instanceof Error ? error.message : String(error),
        };

        console.error(errorRes);

        return errorResponse(request, error);
      }
    }

    return errorResponse(request);
  };

  function errorResponse(request: NextRequest, error?: unknown) {
    if (onError) {
      return onError({ error, request });
    }

    return errorResponseWithFallback({
      error: {
        message: 'Something went wrong',
        description: "Couldn't sign in. If you are not sure what happened, please contact your organization admin.",
      },
    });
  }
}



================================================
FILE: src/cookie.ts
================================================
import {
  WORKOS_REDIRECT_URI,
  WORKOS_COOKIE_MAX_AGE,
  WORKOS_COOKIE_DOMAIN,
  WORKOS_COOKIE_SAMESITE,
} from './env-variables.js';
import { CookieOptions } from './interfaces.js';

type ValidSameSite = CookieOptions['sameSite'];

function assertValidSamSite(sameSite: string): asserts sameSite is ValidSameSite {
  if (!['lax', 'strict', 'none'].includes(sameSite.toLowerCase())) {
    throw new Error(`Invalid SameSite value: ${sameSite}`);
  }
}

export function getCookieOptions(): CookieOptions;
export function getCookieOptions(redirectUri?: string | null): CookieOptions;
export function getCookieOptions(redirectUri: string | null | undefined, asString: true, expired?: boolean): string;
export function getCookieOptions(
  redirectUri: string | null | undefined,
  asString: false,
  expired?: boolean,
): CookieOptions;
export function getCookieOptions(
  redirectUri?: string | null,
  asString?: boolean,
  expired?: boolean,
): CookieOptions | string;
export function getCookieOptions(
  redirectUri?: string | null,
  asString: boolean = false,
  expired: boolean = false,
): CookieOptions | string {
  const url = new URL(redirectUri || WORKOS_REDIRECT_URI);
  const sameSite = WORKOS_COOKIE_SAMESITE || 'lax';
  assertValidSamSite(sameSite);
  const secure = sameSite.toLowerCase() === 'none' ? true : url.protocol === 'https:';

  const maxAge = expired ? 0 : WORKOS_COOKIE_MAX_AGE ? parseInt(WORKOS_COOKIE_MAX_AGE, 10) : 60 * 60 * 24 * 400;

  return asString
    ? `Path=/; HttpOnly; Secure=${secure}; SameSite=${sameSite}; Max-Age=${maxAge}; Domain=${WORKOS_COOKIE_DOMAIN || ''}`
    : {
        path: '/',
        httpOnly: true,
        secure,
        sameSite,
        // Defaults to 400 days, the maximum allowed by Chrome
        // It's fine to have a long cookie expiry date as the access/refresh tokens
        // act as the actual time-limited aspects of the session.
        maxAge,
        domain: WORKOS_COOKIE_DOMAIN || '',
      };
}



================================================
FILE: src/env-variables.ts
================================================
/* istanbul ignore file */

function getEnvVariable(name: string): string | undefined {
  return process.env[name];
}

// Optional env variables
const WORKOS_API_HOSTNAME = getEnvVariable('WORKOS_API_HOSTNAME');
const WORKOS_API_HTTPS = getEnvVariable('WORKOS_API_HTTPS');
const WORKOS_API_PORT = getEnvVariable('WORKOS_API_PORT');
const WORKOS_COOKIE_DOMAIN = getEnvVariable('WORKOS_COOKIE_DOMAIN');
const WORKOS_COOKIE_MAX_AGE = getEnvVariable('WORKOS_COOKIE_MAX_AGE');
const WORKOS_COOKIE_NAME = getEnvVariable('WORKOS_COOKIE_NAME');
const WORKOS_COOKIE_SAMESITE = getEnvVariable('WORKOS_COOKIE_SAMESITE') as 'lax' | 'strict' | 'none' | undefined;

// Required env variables
const WORKOS_API_KEY = getEnvVariable('WORKOS_API_KEY') ?? '';
const WORKOS_CLIENT_ID = getEnvVariable('WORKOS_CLIENT_ID') ?? '';
const WORKOS_COOKIE_PASSWORD = getEnvVariable('WORKOS_COOKIE_PASSWORD') ?? '';
const WORKOS_REDIRECT_URI = process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI ?? '';

export {
  WORKOS_API_HOSTNAME,
  WORKOS_API_HTTPS,
  WORKOS_API_KEY,
  WORKOS_API_PORT,
  WORKOS_CLIENT_ID,
  WORKOS_COOKIE_DOMAIN,
  WORKOS_COOKIE_MAX_AGE,
  WORKOS_COOKIE_NAME,
  WORKOS_COOKIE_PASSWORD,
  WORKOS_REDIRECT_URI,
  WORKOS_COOKIE_SAMESITE,
};



================================================
FILE: src/get-authorization-url.ts
================================================
import { getWorkOS } from './workos.js';
import { WORKOS_CLIENT_ID, WORKOS_REDIRECT_URI } from './env-variables.js';
import { GetAuthURLOptions } from './interfaces.js';
import { headers } from 'next/headers';

async function getAuthorizationUrl(options: GetAuthURLOptions = {}) {
  const headersList = await headers();
  const {
    returnPathname,
    screenHint,
    organizationId,
    redirectUri = headersList.get('x-redirect-uri'),
    loginHint,
  } = options;

  return getWorkOS().userManagement.getAuthorizationUrl({
    provider: 'authkit',
    clientId: WORKOS_CLIENT_ID,
    redirectUri: redirectUri ?? WORKOS_REDIRECT_URI,
    state: returnPathname ? btoa(JSON.stringify({ returnPathname })) : undefined,
    screenHint,
    organizationId,
    loginHint,
  });
}

export { getAuthorizationUrl };



================================================
FILE: src/index.ts
================================================
import { getSignInUrl, getSignUpUrl, signOut, switchToOrganization } from './auth.js';
import { handleAuth } from './authkit-callback-route.js';
import { authkit, authkitMiddleware } from './middleware.js';
import { getTokenClaims, refreshSession, saveSession, withAuth } from './session.js';
import { getWorkOS } from './workos.js';

export * from './interfaces.js';

export {
  authkit,
  authkitMiddleware,
  getSignInUrl,
  getSignUpUrl,
  getWorkOS,
  handleAuth,
  refreshSession,
  saveSession,
  signOut,
  switchToOrganization,
  withAuth,
  getTokenClaims,
};



================================================
FILE: src/interfaces.ts
================================================
import type { AuthenticationResponse, OauthTokens, User } from '@workos-inc/node';
import { type NextRequest } from 'next/server';

export interface HandleAuthOptions {
  returnPathname?: string;
  baseURL?: string;
  onSuccess?: (data: HandleAuthSuccessData) => void | Promise<void>;
  onError?: (params: { error?: unknown; request: NextRequest }) => Response | Promise<Response>;
}

export interface HandleAuthSuccessData extends Session {
  oauthTokens?: OauthTokens;
  organizationId?: string;
  authenticationMethod?: AuthenticationResponse['authenticationMethod'];
}

export interface Impersonator {
  email: string;
  reason: string | null;
}
export interface Session {
  accessToken: string;
  refreshToken: string;
  user: User;
  impersonator?: Impersonator;
}

export interface UserInfo {
  user: User;
  sessionId: string;
  organizationId?: string;
  role?: string;
  permissions?: string[];
  entitlements?: string[];
  featureFlags?: string[];
  impersonator?: Impersonator;
  accessToken: string;
}
export interface NoUserInfo {
  user: null;
  sessionId?: undefined;
  organizationId?: undefined;
  role?: undefined;
  permissions?: undefined;
  entitlements?: undefined;
  featureFlags?: undefined;
  impersonator?: undefined;
  accessToken?: undefined;
}

export interface AccessToken {
  sid: string;
  org_id?: string;
  role?: string;
  permissions?: string[];
  entitlements?: string[];
  feature_flags?: string[];
}

export interface GetAuthURLOptions {
  screenHint?: 'sign-up' | 'sign-in';
  returnPathname?: string;
  organizationId?: string;
  redirectUri?: string;
  loginHint?: string;
}

export interface AuthkitMiddlewareAuth {
  enabled: boolean;
  unauthenticatedPaths: string[];
}

export interface AuthkitMiddlewareOptions {
  debug?: boolean;
  middlewareAuth?: AuthkitMiddlewareAuth;
  redirectUri?: string;
  signUpPaths?: string[];
}

export interface AuthkitOptions {
  debug?: boolean;
  redirectUri?: string;
  screenHint?: 'sign-up' | 'sign-in';
  onSessionRefreshSuccess?: (data: {
    accessToken: string;
    user: User;
    impersonator?: Impersonator;
    organizationId?: string;
  }) => void | Promise<void>;
  onSessionRefreshError?: (params: { error?: unknown; request: NextRequest }) => void | Promise<void>;
}

export interface AuthkitResponse {
  session: UserInfo | NoUserInfo;
  headers: Headers;
  authorizationUrl?: string;
}

export interface CookieOptions {
  path: '/';
  httpOnly: true;
  secure: boolean;
  sameSite: 'lax' | 'strict' | 'none';
  maxAge: number;
  domain: string | undefined;
}

export interface SwitchToOrganizationOptions {
  returnTo?: string;
  revalidationStrategy?: 'none' | 'tag' | 'path';
  revalidationTags?: string[];
}



================================================
FILE: src/middleware.ts
================================================
import { NextMiddleware, NextRequest } from 'next/server';
import { updateSessionMiddleware, updateSession } from './session.js';
import { AuthkitMiddlewareOptions, AuthkitOptions, AuthkitResponse } from './interfaces.js';
import { WORKOS_REDIRECT_URI } from './env-variables.js';

export function authkitMiddleware({
  debug = false,
  middlewareAuth = { enabled: false, unauthenticatedPaths: [] },
  redirectUri = WORKOS_REDIRECT_URI,
  signUpPaths = [],
}: AuthkitMiddlewareOptions = {}): NextMiddleware {
  return function (request) {
    return updateSessionMiddleware(request, debug, middlewareAuth, redirectUri, signUpPaths);
  };
}

export async function authkit(request: NextRequest, options: AuthkitOptions = {}): Promise<AuthkitResponse> {
  return await updateSession(request, options);
}



================================================
FILE: src/session.ts
================================================
'use server';

import { sealData, unsealData } from 'iron-session';
import { JWTPayload, createRemoteJWKSet, decodeJwt, jwtVerify } from 'jose';
import { cookies, headers } from 'next/headers';
import { redirect } from 'next/navigation';
import { NextRequest, NextResponse } from 'next/server';
import { getCookieOptions } from './cookie.js';
import { WORKOS_CLIENT_ID, WORKOS_COOKIE_NAME, WORKOS_COOKIE_PASSWORD, WORKOS_REDIRECT_URI } from './env-variables.js';
import { getAuthorizationUrl } from './get-authorization-url.js';
import {
  AccessToken,
  AuthkitMiddlewareAuth,
  AuthkitOptions,
  AuthkitResponse,
  NoUserInfo,
  Session,
  UserInfo,
} from './interfaces.js';
import { getWorkOS } from './workos.js';

import type { AuthenticationResponse } from '@workos-inc/node';
import { parse, tokensToRegexp } from 'path-to-regexp';
import { lazy, redirectWithFallback } from './utils.js';

const sessionHeaderName = 'x-workos-session';
const middlewareHeaderName = 'x-workos-middleware';
const signUpPathsHeaderName = 'x-sign-up-paths';

const JWKS = lazy(() => createRemoteJWKSet(new URL(getWorkOS().userManagement.getJwksUrl(WORKOS_CLIENT_ID))));

async function encryptSession(session: Session) {
  return sealData(session, {
    password: WORKOS_COOKIE_PASSWORD,
    ttl: 0,
  });
}

async function updateSessionMiddleware(
  request: NextRequest,
  debug: boolean,
  middlewareAuth: AuthkitMiddlewareAuth,
  redirectUri: string,
  signUpPaths: string[],
) {
  if (!redirectUri && !WORKOS_REDIRECT_URI) {
    throw new Error('You must provide a redirect URI in the AuthKit middleware or in the environment variables.');
  }

  if (!WORKOS_COOKIE_PASSWORD || WORKOS_COOKIE_PASSWORD.length < 32) {
    throw new Error(
      'You must provide a valid cookie password that is at least 32 characters in the environment variables.',
    );
  }

  let url;

  if (redirectUri) {
    url = new URL(redirectUri);
  } else {
    url = new URL(WORKOS_REDIRECT_URI);
  }

  if (
    middlewareAuth.enabled &&
    url.pathname === request.nextUrl.pathname &&
    !middlewareAuth.unauthenticatedPaths.includes(url.pathname)
  ) {
    // In the case where:
    // - We're using middleware auth mode
    // - The redirect URI is in the middleware matcher
    // - The redirect URI isn't in the unauthenticatedPaths array
    //
    // then we would get stuck in a login loop due to the redirect happening before the session is set.
    // It's likely that the user accidentally forgot to add the path to unauthenticatedPaths, so we add it here.
    middlewareAuth.unauthenticatedPaths.push(url.pathname);
  }

  const matchedPaths: string[] = middlewareAuth.unauthenticatedPaths.filter((pathGlob) => {
    const pathRegex = getMiddlewareAuthPathRegex(pathGlob);

    return pathRegex.exec(request.nextUrl.pathname);
  });

  const { session, headers, authorizationUrl } = await updateSession(request, {
    debug,
    redirectUri,
    screenHint: getScreenHint(signUpPaths, request.nextUrl.pathname),
  });

  // If the user is logged out and this path isn't on the allowlist for logged out paths, redirect to AuthKit.
  if (middlewareAuth.enabled && matchedPaths.length === 0 && !session.user) {
    if (debug) {
      console.log(`Unauthenticated user on protected route ${request.url}, redirecting to AuthKit`);
    }

    return redirectWithFallback(authorizationUrl as string, headers);
  }

  // Record the sign up paths so we can use them later
  if (signUpPaths.length > 0) {
    headers.set(signUpPathsHeaderName, signUpPaths.join(','));
  }

  return NextResponse.next({
    headers,
  });
}

async function updateSession(
  request: NextRequest,
  options: AuthkitOptions = { debug: false },
): Promise<AuthkitResponse> {
  const session = await getSessionFromCookie(request);

  // Since we're setting the headers in the response, we need to create a new Headers object without copying
  // the request headers.
  // See https://github.com/vercel/next.js/issues/50659#issuecomment-2333990159
  const newRequestHeaders = new Headers();

  // Record that the request was routed through the middleware so we can check later for DX purposes
  newRequestHeaders.set(middlewareHeaderName, 'true');

  // We store the current request url in a custom header, so we can always have access to it
  // This is because on hard navigations we don't have access to `next-url` but need to get the current
  // `pathname` to be able to return the users where they came from before sign-in
  newRequestHeaders.set('x-url', request.url);

  if (options.redirectUri) {
    // Store the redirect URI in a custom header, so we always have access to it and so that subsequent
    // calls to `getAuthorizationUrl` will use the same redirect URI
    newRequestHeaders.set('x-redirect-uri', options.redirectUri);
  }

  newRequestHeaders.delete(sessionHeaderName);

  if (!session) {
    if (options.debug) {
      console.log('No session found from cookie');
    }

    return {
      session: { user: null },
      headers: newRequestHeaders,
      authorizationUrl: await getAuthorizationUrl({
        returnPathname: getReturnPathname(request.url),
        redirectUri: options.redirectUri || WORKOS_REDIRECT_URI,
        screenHint: options.screenHint,
      }),
    };
  }

  const hasValidSession = await verifyAccessToken(session.accessToken);

  const cookieName = WORKOS_COOKIE_NAME || 'wos-session';

  if (hasValidSession) {
    newRequestHeaders.set(sessionHeaderName, request.cookies.get(cookieName)!.value);

    const {
      sid: sessionId,
      org_id: organizationId,
      role,
      permissions,
      entitlements,
      feature_flags: featureFlags,
    } = decodeJwt<AccessToken>(session.accessToken);

    return {
      session: {
        sessionId,
        user: session.user,
        organizationId,
        role,
        permissions,
        entitlements,
        featureFlags,
        impersonator: session.impersonator,
        accessToken: session.accessToken,
      },
      headers: newRequestHeaders,
    };
  }

  try {
    if (options.debug) {
      // istanbul ignore next
      console.log(
        `Session invalid. ${session.accessToken ? `Refreshing access token that ends in ${session.accessToken.slice(-10)}` : 'Access token missing.'}`,
      );
    }

    const { org_id: organizationIdFromAccessToken } = decodeJwt<AccessToken>(session.accessToken);

    const { accessToken, refreshToken, user, impersonator } =
      await getWorkOS().userManagement.authenticateWithRefreshToken({
        clientId: WORKOS_CLIENT_ID,
        refreshToken: session.refreshToken,
        organizationId: organizationIdFromAccessToken,
      });

    if (options.debug) {
      console.log('Session successfully refreshed');
    }
    // Encrypt session with new access and refresh tokens
    const encryptedSession = await encryptSession({
      accessToken,
      refreshToken,
      user,
      impersonator,
    });

    newRequestHeaders.append('Set-Cookie', `${cookieName}=${encryptedSession}; ${getCookieOptions(request.url, true)}`);
    newRequestHeaders.set(sessionHeaderName, encryptedSession);

    const {
      sid: sessionId,
      org_id: organizationId,
      role,
      permissions,
      entitlements,
      feature_flags: featureFlags,
    } = decodeJwt<AccessToken>(accessToken);

    options.onSessionRefreshSuccess?.({ accessToken, user, impersonator, organizationId });

    return {
      session: {
        sessionId,
        user,
        organizationId,
        role,
        permissions,
        entitlements,
        featureFlags,
        impersonator,
        accessToken,
      },
      headers: newRequestHeaders,
    };
  } catch (e) {
    if (options.debug) {
      console.log('Failed to refresh. Deleting cookie.', e);
    }

    // When we need to delete a cookie, return it as a header as you can't delete cookies from edge middleware
    const deleteCookie = `${cookieName}=; Expires=${new Date(0).toUTCString()}; ${getCookieOptions(request.url, true, true)}`;
    newRequestHeaders.append('Set-Cookie', deleteCookie);

    options.onSessionRefreshError?.({ error: e, request });

    return {
      session: { user: null },
      headers: newRequestHeaders,
      authorizationUrl: await getAuthorizationUrl({
        returnPathname: getReturnPathname(request.url),
        redirectUri: options.redirectUri || WORKOS_REDIRECT_URI,
      }),
    };
  }
}

async function refreshSession(options: { organizationId?: string; ensureSignedIn: true }): Promise<UserInfo>;
async function refreshSession(options?: {
  organizationId?: string;
  ensureSignedIn?: boolean;
}): Promise<UserInfo | NoUserInfo>;
async function refreshSession({
  organizationId: nextOrganizationId,
  ensureSignedIn = false,
}: {
  organizationId?: string;
  ensureSignedIn?: boolean;
} = {}): Promise<UserInfo | NoUserInfo> {
  const session = await getSessionFromCookie();
  if (!session) {
    if (ensureSignedIn) {
      await redirectToSignIn();
    }
    return { user: null };
  }

  const { org_id: organizationIdFromAccessToken } = decodeJwt<AccessToken>(session.accessToken);

  let refreshResult;

  try {
    refreshResult = await getWorkOS().userManagement.authenticateWithRefreshToken({
      clientId: WORKOS_CLIENT_ID,
      refreshToken: session.refreshToken,
      organizationId: nextOrganizationId ?? organizationIdFromAccessToken,
    });
  } catch (error) {
    throw new Error(`Failed to refresh session: ${error instanceof Error ? error.message : String(error)}`, {
      cause: error,
    });
  }

  const headersList = await headers();
  const url = headersList.get('x-url');

  await saveSession(refreshResult, url || WORKOS_REDIRECT_URI);

  const { accessToken, user, impersonator } = refreshResult;

  const {
    sid: sessionId,
    org_id: organizationId,
    role,
    permissions,
    entitlements,
    feature_flags: featureFlags,
  } = decodeJwt<AccessToken>(accessToken);

  return {
    sessionId,
    user,
    organizationId,
    role,
    permissions,
    entitlements,
    featureFlags,
    impersonator,
    accessToken,
  };
}

function getMiddlewareAuthPathRegex(pathGlob: string) {
  try {
    const url = new URL(pathGlob, 'https://example.com');
    const path = `${url.pathname!}${url.hash || ''}`;

    const tokens = parse(path);
    const regex = tokensToRegexp(tokens).source;

    return new RegExp(regex);
  } catch (err) {
    console.log('err', err);
    const message = err instanceof Error ? err.message : String(err);

    throw new Error(`Error parsing routes for middleware auth. Reason: ${message}`);
  }
}

async function redirectToSignIn() {
  const headersList = await headers();
  const url = headersList.get('x-url');

  if (!url) {
    throw new Error('No URL found in the headers');
  }

  // Determine if the current route is in the sign up paths
  const signUpPaths = headersList.get(signUpPathsHeaderName)?.split(',');

  const pathname = new URL(url).pathname;
  const screenHint = getScreenHint(signUpPaths, pathname);

  const returnPathname = getReturnPathname(url);

  redirect(await getAuthorizationUrl({ returnPathname, screenHint }));
}

export async function getTokenClaims<T = Record<string, unknown>>(
  accessToken?: string,
): Promise<Partial<JWTPayload & T>> {
  const token = accessToken ?? (await withAuth()).accessToken;
  if (!token) {
    return {};
  }

  return decodeJwt<T>(token);
}

async function withAuth(options: { ensureSignedIn: true }): Promise<UserInfo>;
async function withAuth(options?: { ensureSignedIn?: true | false }): Promise<UserInfo | NoUserInfo>;
async function withAuth(options?: { ensureSignedIn?: boolean }): Promise<UserInfo | NoUserInfo> {
  const session = await getSessionFromHeader();

  if (!session) {
    if (options?.ensureSignedIn) {
      await redirectToSignIn();
    }
    return { user: null };
  }

  const {
    sid: sessionId,
    org_id: organizationId,
    role,
    permissions,
    entitlements,
    feature_flags: featureFlags,
  } = decodeJwt<AccessToken>(session.accessToken);

  return {
    sessionId,
    user: session.user,
    organizationId,
    role,
    permissions,
    entitlements,
    featureFlags,
    impersonator: session.impersonator,
    accessToken: session.accessToken,
  };
}

async function verifyAccessToken(accessToken: string) {
  try {
    await jwtVerify(accessToken, JWKS());
    return true;
  } catch {
    return false;
  }
}

async function getSessionFromCookie(request?: NextRequest) {
  const cookieName = WORKOS_COOKIE_NAME || 'wos-session';
  let cookie;

  if (request) {
    cookie = request.cookies.get(cookieName);
  } else {
    const nextCookies = await cookies();
    cookie = nextCookies.get(cookieName);
  }

  if (cookie) {
    return unsealData<Session>(cookie.value, {
      password: WORKOS_COOKIE_PASSWORD,
    });
  }
}

async function getSessionFromHeader(): Promise<Session | undefined> {
  const headersList = await headers();
  const hasMiddleware = Boolean(headersList.get(middlewareHeaderName));

  if (!hasMiddleware) {
    const url = headersList.get('x-url');
    throw new Error(
      `You are calling 'withAuth' on ${url ?? 'a route'} that isn’t covered by the AuthKit middleware. Make sure it is running on all paths you are calling 'withAuth' from by updating your middleware config in 'middleware.(js|ts)'.`,
    );
  }

  const authHeader = headersList.get(sessionHeaderName);
  if (!authHeader) return;

  return unsealData<Session>(authHeader, { password: WORKOS_COOKIE_PASSWORD });
}

function getReturnPathname(url: string): string {
  const newUrl = new URL(url);

  return `${newUrl.pathname}${newUrl.searchParams.size > 0 ? '?' + newUrl.searchParams.toString() : ''}`;
}

function getScreenHint(signUpPaths: string[] | undefined, pathname: string) {
  if (!signUpPaths) return 'sign-in';

  const screenHintPaths: string[] = signUpPaths.filter((pathGlob) => {
    const pathRegex = getMiddlewareAuthPathRegex(pathGlob);
    return pathRegex.exec(pathname);
  });

  return screenHintPaths.length > 0 ? 'sign-up' : 'sign-in';
}

/**
 * Saves a WorkOS session to a cookie for use with AuthKit.
 *
 * This function is intended for advanced use cases where you need to manually manage sessions,
 * such as custom authentication flows (email verification, etc.) that don't use
 * the standard AuthKit authentication flow.
 *
 * @param sessionOrResponse The WorkOS session or AuthenticationResponse containing access token, refresh token, and user information.
 * @param request Either a NextRequest object or a URL string, used to determine cookie settings.
 *
 * @example
 * // With a NextRequest object
 * import { saveSession } from '@workos-inc/authkit-nextjs';
 *
 * async function handleEmailVerification(req: NextRequest) {
 *   const { code } = await req.json();
 *   const authResponse = await workos.userManagement.authenticateWithEmailVerification({
 *     clientId: process.env.WORKOS_CLIENT_ID,
 *     code,
 *   });
 *
 *   await saveSession(authResponse, req);
 * }
 *
 * @example
 * // With a URL string
 * await saveSession(authResponse, 'https://example.com/callback');
 */
export async function saveSession(
  sessionOrResponse: Session | AuthenticationResponse,
  request: NextRequest | string,
): Promise<void> {
  const cookieName = WORKOS_COOKIE_NAME || 'wos-session';
  const encryptedSession = await encryptSession(sessionOrResponse);
  const nextCookies = await cookies();
  const url = typeof request === 'string' ? request : request.url;
  nextCookies.set(cookieName, encryptedSession, getCookieOptions(url));
}

export { encryptSession, refreshSession, updateSession, updateSessionMiddleware, withAuth };



================================================
FILE: src/utils.ts
================================================
import { NextResponse } from 'next/server';

export function redirectWithFallback(redirectUri: string, headers?: Headers) {
  const newHeaders = headers ? new Headers(headers) : new Headers();
  newHeaders.set('Location', redirectUri);

  // Fall back to standard Response if NextResponse is not available.
  // This is to support Next.js 13.
  return NextResponse?.redirect
    ? NextResponse.redirect(redirectUri, { headers })
    : new Response(null, { status: 307, headers: newHeaders });
}

export function errorResponseWithFallback(errorBody: { error: { message: string; description: string } }) {
  // Fall back to standard Response if NextResponse is not available.
  // This is to support Next.js 13.
  return NextResponse?.json
    ? NextResponse.json(errorBody, { status: 500 })
    : new Response(JSON.stringify(errorBody), {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      });
}

/**
 * Returns a function that can only be called once.
 * Subsequent calls will return the result of the first call.
 * This is useful for lazy initialization.
 * @param fn - The function to be called once.
 * @returns A function that can only be called once.
 */
export function lazy<T>(fn: () => T): () => T {
  let called = false;
  let result: T;
  return () => {
    if (!called) {
      result = fn();
      called = true;
    }
    return result;
  };
}



================================================
FILE: src/workos.ts
================================================
import { WorkOS } from '@workos-inc/node';
import { WORKOS_API_HOSTNAME, WORKOS_API_KEY, WORKOS_API_HTTPS, WORKOS_API_PORT } from './env-variables.js';
import { lazy } from './utils.js';

export const VERSION = '2.4.2';

const options = {
  apiHostname: WORKOS_API_HOSTNAME,
  https: WORKOS_API_HTTPS ? WORKOS_API_HTTPS === 'true' : true,
  port: WORKOS_API_PORT ? parseInt(WORKOS_API_PORT) : undefined,
  appInfo: {
    name: 'authkit/nextjs',
    version: VERSION,
  },
};

/**
 * Create a WorkOS instance with the provided API key and options.
 * If an instance already exists, it returns the existing instance.
 * @returns The WorkOS instance.
 */
export const getWorkOS = lazy(() => new WorkOS(WORKOS_API_KEY, options));



================================================
FILE: src/components/authkit-provider.tsx
================================================
'use client';

import React, { createContext, ReactNode, useContext, useEffect, useState } from 'react';
import {
  checkSessionAction,
  getAuthAction,
  handleSignOutAction,
  refreshAuthAction,
  switchToOrganizationAction,
} from '../actions.js';
import type { Impersonator, User } from '@workos-inc/node';
import type { UserInfo, SwitchToOrganizationOptions } from '../interfaces.js';

type AuthContextType = {
  user: User | null;
  sessionId: string | undefined;
  organizationId: string | undefined;
  role: string | undefined;
  permissions: string[] | undefined;
  entitlements: string[] | undefined;
  featureFlags: string[] | undefined;
  impersonator: Impersonator | undefined;
  loading: boolean;
  getAuth: (options?: { ensureSignedIn?: boolean }) => Promise<void>;
  refreshAuth: (options?: { ensureSignedIn?: boolean; organizationId?: string }) => Promise<void | { error: string }>;
  signOut: (options?: { returnTo?: string }) => Promise<void>;
  switchToOrganization: (
    organizationId: string,
    options?: SwitchToOrganizationOptions,
  ) => Promise<Omit<UserInfo, 'accessToken'> | { error: string }>;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

interface AuthKitProviderProps {
  children: ReactNode;
  /**
   * Customize what happens when a session is expired. By default,the entire page will be reloaded.
   * You can also pass this as `false` to disable the expired session checks.
   */
  onSessionExpired?: false | (() => void);
}

export const AuthKitProvider = ({ children, onSessionExpired }: AuthKitProviderProps) => {
  const [user, setUser] = useState<User | null>(null);
  const [sessionId, setSessionId] = useState<string | undefined>(undefined);
  const [organizationId, setOrganizationId] = useState<string | undefined>(undefined);
  const [role, setRole] = useState<string | undefined>(undefined);
  const [permissions, setPermissions] = useState<string[] | undefined>(undefined);
  const [entitlements, setEntitlements] = useState<string[] | undefined>(undefined);
  const [featureFlags, setFeatureFlags] = useState<string[] | undefined>(undefined);
  const [impersonator, setImpersonator] = useState<Impersonator | undefined>(undefined);
  const [loading, setLoading] = useState(true);

  const getAuth = async ({ ensureSignedIn = false }: { ensureSignedIn?: boolean } = {}) => {
    setLoading(true);
    try {
      const auth = await getAuthAction({ ensureSignedIn });
      setUser(auth.user);
      setSessionId(auth.sessionId);
      setOrganizationId(auth.organizationId);
      setRole(auth.role);
      setPermissions(auth.permissions);
      setEntitlements(auth.entitlements);
      setFeatureFlags(auth.featureFlags);
      setImpersonator(auth.impersonator);
    } catch (error) {
      setUser(null);
      setSessionId(undefined);
      setOrganizationId(undefined);
      setRole(undefined);
      setPermissions(undefined);
      setEntitlements(undefined);
      setFeatureFlags(undefined);
      setImpersonator(undefined);
    } finally {
      setLoading(false);
    }
  };

  const switchToOrganization = async (organizationId: string, options: SwitchToOrganizationOptions = {}) => {
    const opts = { revalidationStrategy: 'none', ...options };
    const result = await switchToOrganizationAction(organizationId, {
      revalidationStrategy: 'none',
      ...options,
    });

    if (opts.revalidationStrategy === 'none') {
      await getAuth({ ensureSignedIn: true });
    }

    return result;
  };

  const refreshAuth = async ({
    ensureSignedIn = false,
    organizationId,
  }: { ensureSignedIn?: boolean; organizationId?: string } = {}) => {
    try {
      setLoading(true);
      const auth = await refreshAuthAction({ ensureSignedIn, organizationId });

      setUser(auth.user);
      setSessionId(auth.sessionId);
      setOrganizationId(auth.organizationId);
      setRole(auth.role);
      setPermissions(auth.permissions);
      setEntitlements(auth.entitlements);
      setFeatureFlags(auth.featureFlags);
      setImpersonator(auth.impersonator);
    } catch (error) {
      return error instanceof Error ? { error: error.message } : { error: String(error) };
    } finally {
      setLoading(false);
    }
  };

  const signOut = async ({ returnTo }: { returnTo?: string } = {}) => {
    await handleSignOutAction({ returnTo });
  };

  useEffect(() => {
    getAuth();

    // Return early if the session expired checks are disabled.
    if (onSessionExpired === false) {
      return;
    }

    let visibilityChangedCalled = false;

    const handleVisibilityChange = async () => {
      if (visibilityChangedCalled) {
        return;
      }

      // In the case where we're using middleware auth mode, a user that has signed out in a different tab
      // will run into an issue if they attempt to hit a server action in the original tab.
      // This will force a refresh of the page in that case, which will redirect them to the sign-in page.
      if (document.visibilityState === 'visible') {
        visibilityChangedCalled = true;

        try {
          const hasSession = await checkSessionAction();
          if (!hasSession) {
            throw new Error('Session expired');
          }
        } catch (error) {
          // 'Failed to fetch' is the error we are looking for if the action fails
          // If any other error happens, for other reasons, we should not reload the page
          if (error instanceof Error && error.message.includes('Failed to fetch')) {
            if (onSessionExpired) {
              onSessionExpired();
            } else {
              window.location.reload();
            }
          }
        } finally {
          visibilityChangedCalled = false;
        }
      }
    };

    window.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('focus', handleVisibilityChange);

    return () => {
      window.removeEventListener('focus', handleVisibilityChange);
      window.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [onSessionExpired]);

  return (
    <AuthContext.Provider
      value={{
        user,
        sessionId,
        organizationId,
        role,
        permissions,
        entitlements,
        featureFlags,
        impersonator,
        loading,
        getAuth,
        refreshAuth,
        signOut,
        switchToOrganization,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export function useAuth(options: {
  ensureSignedIn: true;
}): AuthContextType & ({ loading: true; user: User | null } | { loading: false; user: User });
export function useAuth(options?: { ensureSignedIn?: false }): AuthContextType;
export function useAuth({ ensureSignedIn = false }: { ensureSignedIn?: boolean } = {}) {
  const context = useContext(AuthContext);

  useEffect(() => {
    if (context && ensureSignedIn && !context.user && !context.loading) {
      context.getAuth({ ensureSignedIn });
    }
  }, [ensureSignedIn, context?.user, context?.loading, context?.getAuth]);

  if (!context) {
    throw new Error('useAuth must be used within an AuthKitProvider');
  }

  return context;
}



================================================
FILE: src/components/button.tsx
================================================
import * as React from 'react';

const Button = React.forwardRef<HTMLButtonElement, React.ComponentPropsWithoutRef<'button'>>((props, forwardedRef) => {
  return (
    <button
      ref={forwardedRef}
      type="button"
      {...props}
      style={{
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        flexShrink: 0,
        height: '1.714em',
        padding: '0 0.6em',

        fontFamily: 'inherit',
        fontSize: 'inherit',
        borderRadius: 'min(max(calc(var(--wi-s) * 0.6), 1px), 7px)',
        border: 'none',
        backgroundColor: 'var(--wi-c)',
        color: 'white',

        ...props.style,
      }}
    />
  );
});

Button.displayName = 'Button';

export { Button };



================================================
FILE: src/components/impersonation.tsx
================================================
'use client';

import * as React from 'react';
import { Button } from './button.js';
import { MinMaxButton } from './min-max-button.js';
import { getOrganizationAction, handleSignOutAction } from '../actions.js';
import type { Organization } from '@workos-inc/node';
import { useAuth } from './authkit-provider.js';

interface ImpersonationProps extends React.ComponentPropsWithoutRef<'div'> {
  side?: 'top' | 'bottom';
}

export function Impersonation({ side = 'bottom', ...props }: ImpersonationProps) {
  const { user, impersonator, organizationId, loading } = useAuth();

  const [organization, setOrganization] = React.useState<Organization | null>(null);

  React.useEffect(() => {
    if (!organizationId) return;
    getOrganizationAction(organizationId).then(setOrganization);
  }, [organizationId]);

  if (loading || !impersonator || !user) return null;

  return (
    <div
      {...props}
      data-workos-impersonation-root=""
      style={{
        'position': 'fixed',
        'inset': 0,
        'pointerEvents': 'none',
        'zIndex': 9999,

        // short properties with defaults for authoring convenience
        '--wi-minimized': '0',
        '--wi-s': 'min(max(var(--workos-impersonation-size, 4px), 2px), 15px)',
        '--wi-bgc': 'var(--workos-impersonation-background-color, #fce654)',
        '--wi-c': 'var(--workos-impersonation-color, #1a1600)',
        '--wi-bc': 'var(--workos-impersonation-border-color, #e0c36c)',
        '--wi-bw': 'var(--workos-impersonation-border-width, 1px)',

        ...props.style,
      }}
    >
      <div
        style={{
          '--wi-frame-size': 'calc(var(--wi-s) * (1 - var(--wi-minimized)) + var(--wi-minimized) * var(--wi-bw) * -1)',
          'position': 'absolute',
          'inset': 'calc(var(--wi-frame-size) * -1)',
          'borderRadius': 'calc(var(--wi-frame-size) * 3)',
          'boxShadow': `
						inset 0 0 0 calc(var(--wi-frame-size) * 2) var(--wi-bgc),
						inset 0 0 0 calc(var(--wi-frame-size) * 2 + var(--wi-bw)) var(--wi-bc)
					`,
          'transition': 'all 500ms cubic-bezier(0.16, 1, 0.3, 1)',
        }}
      />

      <div
        style={{
          display: 'flex',
          justifyContent: 'center',

          position: 'fixed',
          left: 0,
          right: 0,
          ...(side === 'top' && { top: 'var(--wi-s)' }),
          ...(side === 'bottom' && { bottom: 'var(--wi-s)' }),

          fontFamily:
            "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif",
          fontSize: 'calc(12px + var(--wi-s) * 0.5)',
          lineHeight: '1.4',
        }}
      >
        <form
          onSubmit={async (event) => {
            event.preventDefault();
            await handleSignOutAction();
          }}
          style={{
            display: 'flex',
            alignItems: 'baseline',
            paddingLeft: 'var(--wi-s)',
            paddingRight: 'var(--wi-s)',

            position: 'relative',
            marginLeft: 'calc(var(--wi-s) * 2)',
            marginRight: 'calc(var(--wi-s) * 2)',

            pointerEvents: 'auto',
            backgroundColor: 'var(--wi-bgc)',
            borderStyle: 'solid',
            borderColor: 'var(--wi-bc)',
            borderLeftWidth: 'var(--wi-bw)',
            borderRightWidth: 'var(--wi-bw)',

            transition: 'all 500ms cubic-bezier(0.16, 1, 0.3, 1)',
            transform: `translateX(calc(var(--wi-minimized) * (var(--wi-s) * 10 - 5%)))`,
            opacity: 'calc(1 - var(--wi-minimized))',
            zIndex: 'calc(1 - var(--wi-minimized))',

            ...(side === 'top' && {
              paddingTop: 0,
              paddingBottom: 'var(--wi-s)',
              borderTopWidth: 0,
              borderBottomWidth: 'var(--wi-bw)',
              borderBottomLeftRadius: 'var(--wi-s)',
              borderBottomRightRadius: 'var(--wi-s)',
            }),

            ...(side === 'bottom' && {
              paddingTop: 'var(--wi-s)',
              paddingBottom: 0,
              borderTopWidth: 'var(--wi-bw)',
              borderBottomWidth: 0,
              borderTopLeftRadius: 'var(--wi-s)',
              borderTopRightRadius: 'var(--wi-s)',
            }),
          }}
        >
          <p style={{ all: 'unset', color: 'var(--wi-c)', textWrap: 'balance', marginLeft: 'var(--wi-s)' }}>
            You are impersonating <b>{user.email}</b>{' '}
            {organization !== null && (
              <>
                within the <b>{organization.name}</b> organization
              </>
            )}
          </p>
          <Button type="submit" style={{ marginLeft: 'calc(var(--wi-s) * 2)', marginRight: 'var(--wi-s)' }}>
            Stop
          </Button>
          <MinMaxButton minimizedValue="1">{side === 'top' ? '↗' : '↘'}</MinMaxButton>
        </form>

        <div
          style={{
            padding: 'var(--wi-s)',

            position: 'fixed',
            right: 'var(--wi-s)',

            pointerEvents: 'auto',
            backgroundColor: 'var(--wi-bgc)',
            border: 'var(--wi-bw) solid var(--wi-bc)',
            borderRadius: 'var(--wi-s)',

            transition: 'all 500ms cubic-bezier(0.16, 1, 0.3, 1)',
            transform: 'translateX(calc((1 - var(--wi-minimized)) * var(--wi-s) * -5))',
            opacity: 'var(--wi-minimized)',
            zIndex: 'var(--wi-minimized)',

            ...(side === 'top' && { top: 'var(--wi-s)' }),
            ...(side === 'bottom' && { bottom: 'var(--wi-s)' }),
          }}
        >
          <MinMaxButton minimizedValue="0">{side === 'top' ? '↙' : '↖'}</MinMaxButton>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/index.ts
================================================
import { Impersonation } from './impersonation.js';
import { AuthKitProvider, useAuth } from './authkit-provider.js';
import { useAccessToken } from './useAccessToken.js';
import { useTokenClaims } from './useTokenClaims.js';

export { Impersonation, AuthKitProvider, useAuth, useAccessToken, useTokenClaims };



================================================
FILE: src/components/min-max-button.tsx
================================================
'use client';

import * as React from 'react';
import { Button } from './button.js';

interface MinMaxButtonProps {
  children?: React.ReactNode;
  minimizedValue: '0' | '1';
}

export function MinMaxButton({ children, minimizedValue }: MinMaxButtonProps) {
  return (
    <Button
      onClick={() => {
        const root = document.querySelector('[data-workos-impersonation-root]') as HTMLElement | null;
        root?.style.setProperty('--wi-minimized', minimizedValue);
      }}
      style={{ padding: 0, width: '1.714em' }}
    >
      {children}
    </Button>
  );
}



================================================
FILE: src/components/useAccessToken.ts
================================================
import { useCallback, useEffect, useReducer, useRef } from 'react';
import { getAccessTokenAction, refreshAccessTokenAction } from '../actions.js';
import { useAuth } from './authkit-provider.js';

const TOKEN_EXPIRY_BUFFER_SECONDS = 60;
const MIN_REFRESH_DELAY_SECONDS = 15; // minimum delay before refreshing token
const MAX_REFRESH_DELAY_SECONDS = 24 * 60 * 60; // 24 hours
const RETRY_DELAY_SECONDS = 300; // 5 minutes

interface TokenState {
  token: string | undefined;
  loading: boolean;
  error: Error | null;
}

type TokenAction =
  | { type: 'FETCH_START' }
  | { type: 'FETCH_SUCCESS'; token: string | undefined }
  | { type: 'FETCH_ERROR'; error: Error }
  | { type: 'RESET' };

function tokenReducer(state: TokenState, action: TokenAction): TokenState {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, token: action.token };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.error };
    case 'RESET':
      return { ...state, token: undefined, loading: false, error: null };
    // istanbul ignore next
    default:
      return state;
  }
}

function getRefreshDelay(timeUntilExpiry: number) {
  const idealDelay = (timeUntilExpiry - TOKEN_EXPIRY_BUFFER_SECONDS) * 1000;
  return Math.min(Math.max(idealDelay, MIN_REFRESH_DELAY_SECONDS * 1000), MAX_REFRESH_DELAY_SECONDS * 1000);
}

function parseToken(token: string | undefined) {
  // istanbul ignore next
  if (!token) {
    return null;
  }

  try {
    const parts = token.split('.');
    if (parts.length !== 3) {
      return null;
    }

    const payload = JSON.parse(atob(parts[1]));
    const now = Math.floor(Date.now() / 1000);

    return {
      payload,
      expiresAt: payload.exp,
      isExpiring: payload.exp < now + TOKEN_EXPIRY_BUFFER_SECONDS,
      timeUntilExpiry: payload.exp - now,
    };
  } catch {
    // istanbul ignore next
    return null;
  }
}

/**
 * A hook that manages access tokens with automatic refresh.
 */
export function useAccessToken() {
  const { user, sessionId, refreshAuth } = useAuth();
  const userId = user?.id;
  const [state, dispatch] = useReducer(tokenReducer, {
    token: undefined,
    loading: false,
    error: null,
  });

  const refreshTimeoutRef = useRef<ReturnType<typeof setTimeout>>();
  const fetchingRef = useRef(false);

  const clearRefreshTimeout = useCallback(() => {
    if (refreshTimeoutRef.current) {
      clearTimeout(refreshTimeoutRef.current);
      refreshTimeoutRef.current = undefined;
    }
  }, []);

  const updateToken = useCallback(async () => {
    // istanbul ignore next - safety guard against concurrent fetches
    if (fetchingRef.current) {
      return;
    }

    fetchingRef.current = true;
    dispatch({ type: 'FETCH_START' });
    try {
      let token = await getAccessTokenAction();
      if (token) {
        const tokenData = parseToken(token);
        if (!tokenData || tokenData.isExpiring) {
          token = await refreshAccessTokenAction();
        }
      }

      dispatch({ type: 'FETCH_SUCCESS', token });

      if (token) {
        const tokenData = parseToken(token);
        if (tokenData) {
          const delay = getRefreshDelay(tokenData.timeUntilExpiry);
          clearRefreshTimeout();
          refreshTimeoutRef.current = setTimeout(updateToken, delay);
        }
      }

      return token;
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', error: error instanceof Error ? error : new Error(String(error)) });
      refreshTimeoutRef.current = setTimeout(updateToken, RETRY_DELAY_SECONDS * 1000);
    } finally {
      fetchingRef.current = false;
    }
  }, [clearRefreshTimeout]);

  const refresh = useCallback(async () => {
    if (fetchingRef.current) {
      return;
    }

    fetchingRef.current = true;
    dispatch({ type: 'FETCH_START' });

    try {
      await refreshAuth();
      const token = await getAccessTokenAction();

      dispatch({ type: 'FETCH_SUCCESS', token });

      if (token) {
        const tokenData = parseToken(token);
        if (tokenData) {
          const delay = getRefreshDelay(tokenData.timeUntilExpiry);
          clearRefreshTimeout();
          refreshTimeoutRef.current = setTimeout(updateToken, delay);
        }
      }

      return token;
    } catch (error) {
      const typedError = error instanceof Error ? error : new Error(String(error));
      dispatch({ type: 'FETCH_ERROR', error: typedError });
      refreshTimeoutRef.current = setTimeout(updateToken, RETRY_DELAY_SECONDS * 1000);
    } finally {
      fetchingRef.current = false;
    }
  }, [refreshAuth, clearRefreshTimeout, updateToken]);

  useEffect(() => {
    if (!user) {
      dispatch({ type: 'RESET' });
      clearRefreshTimeout();
      return;
    }
    updateToken();

    return clearRefreshTimeout;
  }, [userId, sessionId, updateToken, clearRefreshTimeout]);

  return {
    accessToken: state.token,
    loading: state.loading,
    error: state.error,
    refresh,
  };
}



================================================
FILE: src/components/useTokenClaims.ts
================================================
import { useMemo } from 'react';
import { useAccessToken } from './useAccessToken.js';
import { decodeJwt, type JWTPayload } from 'jose';

type TokenClaims<T> = Partial<JWTPayload & T>;

/**
 * A hook that retrieves the claims from the access token.
 *
 * @example
 * ```ts
 * const {customClaim, iat } = useTokenClaims<{ customClaim: string }>();
 * ```
 * @returns The claims from the access token, or an empty object if the token is not available or cannot be parsed.
 */
export function useTokenClaims<T = Record<string, unknown>>(): TokenClaims<T> {
  const { accessToken } = useAccessToken();

  return useMemo(() => {
    if (!accessToken) {
      return {};
    }

    try {
      return decodeJwt<T>(accessToken);
    } catch {
      return {};
    }
  }, [accessToken]);
}



================================================
FILE: types/react.d.ts
================================================
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import * as React from 'react';

declare module 'react' {
  interface CSSProperties {
    [key: `--${string}`]: unknown;
  }
}

export {};



================================================
FILE: .github/CODEOWNERS
================================================
# See GitHub's docs for more details:
# https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-code-owners

# TypeScript Team
* @workos/typescript




================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - authkit-nextjs version [e.g. 0.12.0]
 - Next.js version [e.g. 14.2.5]

**Additional context**
Add any other context about the problem here.



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

on:
  push:
    branches:
      - 'main'
  pull_request: {}

defaults:
  run:
    shell: bash

jobs:
  test:
    name: Test Node ${{ matrix.node }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [18, 20, 22]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}

      - name: Install Dependencies
        run: |
          npm install

      - name: Prettier
        run: |
          npm run prettier

      - name: Lint
        run: |
          npm run lint

      - name: Build
        run: |
          npm run build

      - name: Test
        run: |
          npm run test -- --coverage



================================================
FILE: .github/workflows/coana-analysis.yml
================================================
name: Coana Vulnerability Analysis

on:
  schedule:
    - cron: '0 3 * * *' # every day at 3 AM
  workflow_dispatch:
    inputs:
      tags:
        description: 'Manually run vulnerability analysis'
      # Required by the return-dispatch action
      distinct_id:

jobs:
  coana-vulnerability-analysis:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Coana CLI
        id: coana-cli
        uses: docker://coana/coana:latest
        with:
          args: |
            coana run . \
              --api-key ${{ secrets.COANA_API_KEY }} \
              --repo-url https://github.com/${{github.repository}}



================================================
FILE: .github/workflows/coana-guardrail.yml
================================================
name: Coana Guardrail

on: pull_request

jobs:
  guardrail:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout the ${{github.base_ref}} branch
        uses: actions/checkout@v4
        with:
          ref: ${{github.base_ref}} # checkout the base branch (usually master/main).

      - name: Fetch the PR branch
        run: |
          git fetch ${{ github.event.pull_request.head.repo.clone_url }} ${{ github.head_ref }}:${{ github.head_ref }} --depth=1

      - name: Get list of changed files relative to the main/master branch
        id: changed-files
        run: |
          echo "all_changed_files=$(git diff --name-only ${{ github.base_ref }} ${{ github.head_ref }} | tr '\n' ' ')" >> $GITHUB_OUTPUT

      - name: Use Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: 20.x

      - name: Run Coana on the ${{github.base_ref}} branch
        run: |
          npx @coana-tech/cli run . \
            --guardrail-mode \
            --api-key ${{ secrets.COANA_API_KEY || 'api-key-unavailable' }} \
            -o /tmp/main-branch \
            --changed-files ${{ steps.changed-files.outputs.all_changed_files }} \
            --lightweight-reachability \

      # Reset file permissions.
      # This is necessary because the Coana CLI may add
      # new files with root ownership since it's using docker.
      # These files will not be deleted by the clean step in checkout
      # if the permissions are not reset.
      - name: Reset file permissions
        run: sudo chown -R $USER:$USER .

      - name: Checkout the current branch
        uses: actions/checkout@v4
        with:
          clean: true

      - name: Run Coana on the current branch
        run: |
          npx @coana-tech/cli run . \
            --guardrail-mode \
            --api-key ${{ secrets.COANA_API_KEY || 'api-key-unavailable' }} \
            -o /tmp/current-branch \
            --changed-files ${{ steps.changed-files.outputs.all_changed_files }} \
            --lightweight-reachability \

      - name: Run Report Comparison
        run: |
          npx @coana-tech/cli compare-reports \
            --api-key ${{ secrets.COANA_API_KEY || 'api-key-unavailable' }} \
            /tmp/main-branch/coana-report.json \
            /tmp/current-branch/coana-report.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



================================================
FILE: .github/workflows/release.yml
================================================
name: Release

on:
  # Support manually pushing a new release
  workflow_dispatch: {}
  # Trigger when a release is published
  release:
    types: [published]

defaults:
  run:
    shell: bash

jobs:
  test:
    name: Publish to NPM
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 18
          registry-url: 'https://registry.npmjs.org'

      - name: Install Dependencies
        run: |
          npm install

      - name: Build project
        run: |
          npm run build

      - name: Push Release
        if: ${{ !github.event.release.prerelease }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          npm publish --tag latest --access=public

      - name: Push Pre-Release
        if: ${{ github.event.release.prerelease }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          npm publish --tag next --access=public


